文件名: client/frame_sync/frame_executor.py
文件内容
======================================================================
# client/frame_sync/frame_executor.py
from collections import defaultdict, deque
from common.constants import *


class FrameExecutor:
    def __init__(self, game_client):
        self.game_client = game_client  # 引用游戏客户端实例
        self.current_frame = 0
        self.turn_size = 5  # 与服务器保持一致
        self.input_buffer = defaultdict(dict)  # frame -> {client_id -> inputs}
        self.waiting_for_input = False
        self.last_executed_turn = -1

    def add_input_frame(self, frame, inputs):
        """添加从服务器接收的输入帧"""
        for frame_num, frame_inputs in inputs.items():
            self.input_buffer[int(frame_num)].update(frame_inputs)

        # 如果正在等待输入，尝试恢复执行
        if self.waiting_for_input:
            self.execute_frame()

    def execute_frame(self):
        """执行当前帧的游戏逻辑"""
        # 检查是否需要处理输入（每turn_size帧一次）
        current_turn = self.current_frame // self.turn_size

        if current_turn > self.last_executed_turn:
            # 需要新的输入数据
            start_frame = current_turn * self.turn_size
            end_frame = start_frame + self.turn_size - 1

            # 检查是否有所有需要的帧
            has_all_frames = True
            for frame in range(start_frame, end_frame + 1):
                if frame not in self.input_buffer:
                    has_all_frames = False
                    break

            if not has_all_frames:
                # 没有收到所有需要的输入帧，停止执行逻辑
                self.waiting_for_input = True
                return False

            # 有所有需要的帧，继续执行
            self.waiting_for_input = False
            self.last_executed_turn = current_turn

            # 应用所有客户端的输入
            for client_id, inputs in self.input_buffer[self.current_frame].items():
                self.apply_input(client_id, inputs)

        # 更新游戏状态
        self.game_client.update_game_state()

        # 增加帧计数
        self.current_frame += 1
        return True

    def apply_input(self, client_id, inputs):
        """将输入应用到对应的游戏对象"""
        # 找到对应client_id的坦克
        tank = None
        if self.game_client.player_tank and self.game_client.player_tank.tank_id == client_id:
            tank = self.game_client.player_tank
        else:
            for enemy_tank in self.game_client.enemy_tanks:
                if enemy_tank.tank_id == client_id:
                    tank = enemy_tank
                    break

        # 应用输入
        if tank:
            tank.apply_input(inputs)

            # 处理射击
            if inputs.get('shoot'):
                self.game_client.handle_tank_shoot(tank)

文件名: client/frame_sync/input_manager.py
文件内容
======================================================================
# client/frame_sync/input_manager.py
import pygame
from common.constants import *


class InputManager:
    def __init__(self):
        self.current_inputs = {}
        self.previous_inputs = {}
        self.input_changed = False

    # client/frame_sync/input_manager.py
    def capture_input(self):
        """捕获当前帧的用户输入"""
        keys = pygame.key.get_pressed()

        # 清空当前输入
        self.previous_inputs = self.current_inputs.copy()
        self.current_inputs = {}

        # 移动输入
        if keys[pygame.K_w] or keys[pygame.K_UP]:
            self.current_inputs['movement'] = 'up'
            print("[Input] Captured: UP")
        elif keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            self.current_inputs['movement'] = 'right'
            print("[Input] Captured: RIGHT")
        elif keys[pygame.K_s] or keys[pygame.K_DOWN]:
            self.current_inputs['movement'] = 'down'
            print("[Input] Captured: DOWN")
        elif keys[pygame.K_a] or keys[pygame.K_LEFT]:
            self.current_inputs['movement'] = 'left'
            print("[Input] Captured: LEFT")
        else:
            self.current_inputs['movement'] = 'stop'

        # 射击输入
        self.current_inputs['shoot'] = keys[pygame.K_SPACE]
        if keys[pygame.K_SPACE]:
            print("[Input] Captured: SHOOT")

        # 检查输入是否变化
        self.input_changed = self.current_inputs != self.previous_inputs
        if self.input_changed:
            print(f"[Input] Input changed: {self.current_inputs}")

        return self.current_inputs

    def has_input_changed(self):
        """检查输入是否与上一帧相比发生变化"""
        return self.input_changed

    def serialize_input(self):
        """将输入序列化为可传输格式"""
        return self.current_inputs

文件名: client/frame_sync/state_synchronizer.py
文件内容
======================================================================
# state_synchronizer.py
"""
状态同步器模块：处理客户端与服务器之间的状态同步

主要功能：
- 发送本地输入到服务器
- 接收和应用服务器状态更新
- 处理预测和校正
"""

import time
import pygame
from common.frame_data import InputFrame, StateFrame
from common.protocol import create_input_message, NetworkLatencyEstimator


class StateSynchronizer:
    """
    状态同步器：处理客户端与服务器之间的状态同步

    主要功能：
    - 管理本地和远程状态
    - 处理状态校正
    - 发送输入和接收状态更新
    """

    def __init__(self, network_client, frame_executor, input_manager, local_player_id):
        """
        初始化状态同步器

        Args:
            network_client: 网络客户端对象
            frame_executor: 帧执行器
            input_manager: 输入管理器
            local_player_id: 本地玩家ID
        """
        self.network_client = network_client
        self.frame_executor = frame_executor
        self.input_manager = input_manager
        self.local_player_id = local_player_id

        # 状态同步参数
        self.input_delay = 2  # 本地输入延迟帧数
        self.prediction_window = 10  # 预测窗口大小

        # 网络延迟估计
        self.latency_estimator = NetworkLatencyEstimator()

        # 状态指标
        self.correction_count = 0
        self.last_mismatch_time = 0
        self.mismatch_count = 0

    def send_input(self, frame_id, input_command):
        """
        发送输入命令到服务器

        Args:
            frame_id: 帧ID
            input_command: 输入命令
        """
        # 创建输入消息
        input_message = create_input_message(
            player_id=self.local_player_id,
            frame_id=frame_id,
            input_command=input_command
        )

        # 发送消息
        self.network_client.send_message(input_message)

        # 存储输入到本地历史
        self.input_manager.store_input(frame_id, input_command)

        # 创建并添加输入帧到帧执行器
        input_frame = InputFrame(frame_id=frame_id)
        input_frame.add_command(self.local_player_id, input_command)
        self.frame_executor.add_input_frame(input_frame)

    def apply_state_update(self, state_frame):
        """
        应用服务器的状态更新

        Args:
            state_frame: 状态帧

        Returns:
            bool: 是否需要进行状态校正
        """
        # 添加状态帧到帧执行器
        self.frame_executor.add_state_frame(state_frame)

        # 更新确认帧
        self.frame_executor.set_confirmed_frame(state_frame.frame_id)

        # 检查是否需要状态校正
        need_correction = self._check_state_mismatch(state_frame)

        if need_correction:
            # 执行状态校正
            self._perform_correction(state_frame)
            self.correction_count += 1

        return need_correction

    def _check_state_mismatch(self, server_state_frame):
        """
        检查本地状态与服务器状态是否不匹配

        Args:
            server_state_frame: 服务器发送的状态帧

        Returns:
            bool: 如果状态不匹配则返回True
        """
        # 如果服务器帧比本地执行的帧新，不进行校验
        if server_state_frame.frame_id > self.frame_executor.last_executed_frame_id:
            return False

        # 如果服务器帧太旧，不进行校验
        if server_state_frame.frame_id < self.frame_executor.last_executed_frame_id - self.prediction_window:
            return False

        # 获取本地状态帧
        local_state_frame = self.frame_executor.frame_buffer.get_state_frame(server_state_frame.frame_id)

        # 如果没有本地帧，需要校正
        if not local_state_frame:
            return True

        # 比较状态校验和
        if local_state_frame.checksum != server_state_frame.checksum:
            # 记录不匹配
            current_time = time.time()
            if current_time - self.last_mismatch_time > 5:  # 每5秒最多记录一次
                self.last_mismatch_time = current_time
                self.mismatch_count += 1
                print(f"State mismatch at frame {server_state_frame.frame_id}")
            return True

        return False

    def _perform_correction(self, server_state_frame):
        """
        执行状态校正

        Args:
            server_state_frame: 服务器发送的状态帧
        """
        # 回滚到服务器帧，并重新执行
        target_frame_id = self.frame_executor.current_frame_id - 1

        # 加载服务器状态
        self.frame_executor.game_engine.load_state(server_state_frame.game_state)

        # 更新执行状态
        self.frame_executor.last_executed_frame_id = server_state_frame.frame_id

        # 执行到当前帧
        if target_frame_id > server_state_frame.frame_id:
            self.frame_executor.execute_frame(target_frame_id)

    def update(self, events, keys_pressed):
        """
        更新状态同步

        Args:
            events: pygame事件列表
            keys_pressed: pygame按键状态

        Returns:
            bool: 是否有新的帧执行
        """
        # 计算目标帧（考虑输入延迟）
        target_frame_id = self.frame_executor.current_frame_id + self.input_delay

        # 捕获当前输入
        input_command = self.input_manager.capture_input(events, keys_pressed)

        # 发送输入到服务器
        self.send_input(target_frame_id, input_command)

        # 执行当前帧（帧执行器内部会决定是否需要回滚）
        frame_executed = self.frame_executor.execute_frame()

        return frame_executed

    def get_statistics(self):
        """
        获取同步统计信息

        Returns:
            dict: 同步统计信息
        """
        return {
            'current_frame': self.frame_executor.current_frame_id,
            'confirmed_frame': self.frame_executor.last_confirmed_frame_id,
            'input_delay': self.input_delay,
            'latency': self.latency_estimator.get_average_rtt(),
            'corrections': self.correction_count,
            'mismatches': self.mismatch_count,
            'rollbacks': self.frame_executor.rollback_count
        }

    def adjust_input_delay(self):
        """根据网络延迟自动调整输入延迟"""
        # 获取平均往返时间（毫秒）
        avg_rtt = self.latency_estimator.get_average_rtt()

        # 计算需要的帧数（每帧33.3ms，对应30FPS）
        frames_needed = int(avg_rtt / (1000 / LOGIC_TICK_RATE))) + 1

        # 确保最小延迟
        self.input_delay = max(2, min(frames_needed, 10))

文件名: client/game_engine/bullet.py
文件内容
======================================================================
# bullet.py
"""
子弹类模块：定义游戏中的子弹对象及其行为
"""

import pygame
import math
from common.constants import *
from common.utils import vector_from_angle
from common.deterministic_engine import DeterministicPhysics


class Bullet:
    """
    子弹类：表示游戏中的子弹对象

    主要功能：
    - 初始化子弹（位置、方向等）
    - 子弹移动
    - 碰撞检测
    - 绘制子弹
    """

    def __init__(self, position, direction, owner_id=None):
        """初始化子弹对象"""
        self.x, self.y = position
        self.direction = direction  # 方向角度，0表示向右，90表示向下，以此类推
        self.owner_id = owner_id  # 发射子弹的坦克ID

        # 子弹属性
        self.speed = BULLET_SPEED
        self.damage = BULLET_DAMAGE
        self.radius = BULLET_RADIUS
        self.lifetime = BULLET_LIFETIME * 1000  # 转换为毫秒
        self.color = COLOR_WHITE
        self.active = True  # 子弹是否活跃

        # 计算子弹速度向量
        angle_rad = math.radians(self.direction)
        self.velocity = vector_from_angle(angle_rad, self.speed)

        # 子弹碰撞盒（圆形）
        self.rect = (self.x - self.radius, self.y - self.radius,
                     self.radius * 2, self.radius * 2)

        # 记录创建时间
        self.creation_time = pygame.time.get_ticks()

    def update(self, delta_time, obstacles, tanks):
        """
        更新子弹位置，检测碰撞
        返回碰撞结果（是否命中，命中的对象）
        """
        if not self.active:
            return None, None

        # 检查子弹是否超过生命周期
        current_time = pygame.time.get_ticks()
        if current_time - self.creation_time > self.lifetime:
            self.active = False
            return None, None

        # 更新位置，使用 delta_time 使移动更平滑
        self.x += self.velocity[0] * delta_time * 60  # 乘以60使速度在60FPS下保持一致
        self.y += self.velocity[1] * delta_time * 60

        # 更新碰撞盒
        self.rect = (self.x - self.radius, self.y - self.radius,
                     self.radius * 2, self.radius * 2)

        # 检查是否超出屏幕
        if (self.x < 0 or self.x > SCREEN_WIDTH or
                self.y < 0 or self.y > SCREEN_HEIGHT):
            self.active = False
            return None, None

        # 检查与障碍物的碰撞
        for obstacle in obstacles:
            if getattr(obstacle, 'destroyed', False):
                continue
            if DeterministicPhysics.check_collision(self.rect, obstacle.rect):
                self.active = False
                obstacle.take_damage(self.damage)
                return "obstacle", obstacle

        # 检查与坦克的碰撞(排除自己的坦克)
        for tank in tanks:
            if tank and tank.tank_id != self.owner_id and not getattr(tank, 'is_destroyed', False):  # 不检查与发射者或已销毁坦克的碰撞
                if DeterministicPhysics.check_collision(self.rect, tank.rect):
                    self.active = False
                    tank.take_damage(self.damage)  # 这会触发视觉效果
                    return "tank", tank

        return None, None

    def draw(self, surface):
        """绘制子弹"""
        if not self.active:
            return

        # 绘制子弹（圆形）
        pygame.draw.circle(surface, self.color, (int(self.x), int(self.y)), self.radius)

    def serialize(self):
        """将子弹状态序列化为字典"""
        return {
            'position': (self.x, self.y),
            'direction': self.direction,
            'owner_id': self.owner_id,
            'velocity': self.velocity,
            'active': self.active,
            'creation_time': self.creation_time
        }

    @classmethod
    def deserialize(cls, data):
        """从序列化数据创建子弹"""
        bullet = cls(data['position'], data['direction'], data['owner_id'])
        bullet.velocity = data['velocity']
        bullet.active = data['active']
        bullet.creation_time = data['creation_time']
        return bullet

文件名: client/game_engine/collision.py
文件内容
======================================================================
# collision.py
"""
碰撞系统模块：处理游戏中的碰撞检测
"""

from common.deterministic_engine import DeterministicPhysics


class CollisionSystem:
    """
    碰撞系统：处理游戏中的碰撞检测

    主要功能：
    - 检测坦克与障碍物的碰撞
    - 检测坦克与坦克的碰撞
    - 检测子弹与物体的碰撞
    """

    @staticmethod
    def check_tank_obstacle_collision(tank, obstacles):
        """
        检查坦克与障碍物的碰撞

        Args:
            tank: 坦克对象
            obstacles: 障碍物列表

        Returns:
            碰撞的障碍物列表
        """
        collided_obstacles = []

        # 使用稍小的碰撞盒，允许坦克通过狭窄空间
        collision_shrink = 2  # 每边缩小的像素数
        tank_collision_box = (
            tank.x - tank.width / 2 + collision_shrink,
            tank.y - tank.height / 2 + collision_shrink,
            tank.width - 2 * collision_shrink,
            tank.height - 2 * collision_shrink
        )

        for obstacle in obstacles:
            if getattr(obstacle, 'destroyed', False):
                continue
            if DeterministicPhysics.check_collision(tank_collision_box, obstacle.rect):
                collided_obstacles.append(obstacle)

        return collided_obstacles

    @staticmethod
    def check_tank_tank_collision(tank, other_tanks):
        """
        检查坦克与其他坦克的碰撞

        Args:
            tank: 待检查的坦克
            other_tanks: 其他坦克列表

        Returns:
            (是否碰撞, 碰撞的坦克)
        """
        # 使用稍小的碰撞盒，允许坦克更容易通过
        collision_shrink = 1  # 每边缩小的像素数
        tank_collision_box = (
            tank.x - tank.width / 2 + collision_shrink,
            tank.y - tank.height / 2 + collision_shrink,
            tank.width - 2 * collision_shrink,
            tank.height - 2 * collision_shrink
        )

        for other_tank in other_tanks:
            if other_tank == tank or getattr(other_tank, 'is_destroyed', False):
                continue

            other_tank_collision_box = (
                other_tank.x - other_tank.width / 2 + collision_shrink,
                other_tank.y - other_tank.height / 2 + collision_shrink,
                other_tank.width - 2 * collision_shrink,
                other_tank.height - 2 * collision_shrink
            )

            if DeterministicPhysics.check_collision(tank_collision_box, other_tank_collision_box):
                return True, other_tank

        return False, None

    @staticmethod
    def check_bullet_obstacle_collision(bullet, obstacles):
        """
        检查子弹与障碍物的碰撞

        Args:
            bullet: 子弹对象
            obstacles: 障碍物列表

        Returns:
            (是否碰撞, 碰撞的障碍物)
        """
        if not bullet.active:
            return False, None

        for obstacle in obstacles:
            if getattr(obstacle, 'destroyed', False):
                continue
            if DeterministicPhysics.check_collision(bullet.rect, obstacle.rect):
                return True, obstacle

        return False, None

    @staticmethod
    def check_bullet_tank_collision(bullet, tanks):
        """
        检查子弹与坦克的碰撞

        Args:
            bullet: 子弹对象
            tanks: 坦克列表

        Returns:
            (是否碰撞, 碰撞的坦克)
        """
        if not bullet.active:
            return False, None

        for tank in tanks:
            # 跳过子弹所有者的坦克和已销毁的坦克
            if tank.tank_id == bullet.owner_id or getattr(tank, 'is_destroyed', False):
                continue

            if DeterministicPhysics.check_collision(bullet.rect, tank.rect):
                return True, tank

        return False, None

    @staticmethod
    def check_screen_bounds(position, size, screen_width, screen_height, margin=0):
        """
        检查对象是否超出屏幕边界

        Args:
            position: 对象位置 (x, y) - 中心点
            size: 对象大小 (width, height)
            screen_width, screen_height: 屏幕尺寸
            margin: 边界余量

        Returns:
            是否在屏幕边界内
        """
        x, y = position
        width, height = size

        half_width = width / 2
        half_height = height / 2

        return (
                x - half_width + margin >= 0 and
                x + half_width - margin <= screen_width and
                y - half_height + margin >= 0 and
                y + half_height - margin <= screen_height
        )

    @staticmethod
    def handle_tank_collision(moving_tank, other_tanks):
        """
        处理坦克与其他坦克的碰撞

        Args:
            moving_tank: 移动中的坦克
            other_tanks: 其他坦克列表

        Returns:
            是否发生碰撞
        """
        collision, collided_tank = CollisionSystem.check_tank_tank_collision(
            moving_tank, other_tanks
        )

        if collision:
            # 撤销移动
            moving_tank.x = moving_tank.prev_x
            moving_tank.y = moving_tank.prev_y

            # 更新碰撞盒
            moving_tank.collision_box = (
                moving_tank.x - moving_tank.width / 2,
                moving_tank.y - moving_tank.height / 2,
                moving_tank.width,
                moving_tank.height
            )

            # 更新视觉矩形
            moving_tank.update_image()

            # 显示碰撞效果
            moving_tank.show_collision_effect()
            collided_tank.show_collision_effect()

            return True

        return False

文件名: client/game_engine/map.py
文件内容
======================================================================
# map.py
"""
地图类模块：定义游戏地图和障碍物的生成与管理
"""

import pygame
import random
import os
import json
import math
from common.constants import *
from client.game_engine.obstacle import WallObstacle, BrickObstacle
from common.deterministic_engine import DeterministicRandom, DeterministicPhysics


class Map:
    """
    地图类：管理游戏地图和障碍物

    主要功能：
    - 地图生成（随机和预设）
    - 障碍物管理
    - 出生点管理
    - 地图渲染
    """

    def __init__(self, map_name=None):
        """初始化地图对象"""
        self.screen_width = SCREEN_WIDTH
        self.screen_height = SCREEN_HEIGHT
        self.grid_size = GRID_SIZE
        self.map_width = MAP_WIDTH
        self.map_height = MAP_HEIGHT

        # 使用确定性随机生成器
        self.random = DeterministicRandom()

        # 地图网格
        self.grid = [[0 for _ in range(self.map_width)] for _ in range(self.map_height)]

        # 障碍物列表
        self.obstacles = []

        # 出生点列表
        self.spawn_points = []

        # 如果提供了地图名称，则加载，否则生成默认地图
        if map_name:
            self.load_map(map_name)
        else:
            self.generate_default_map()

    def generate_default_map(self):
        """生成默认地图"""
        # 创建边界墙
        self._create_boundaries()

        # 随机生成一些砖块
        self._generate_random_bricks(15)

        # 初始化默认出生点 - 确保它们远离障碍物
        self._initialize_default_spawn_points()

    def generate_random_map(self, seed=None):
        """生成随机地图"""
        if seed is not None:
            self.random.seed(seed)

        # 清空已有障碍物
        self.obstacles = []
        self.spawn_points = []

        # 创建边界墙
        self._create_boundaries()

        # 随机生成砖块
        self._generate_random_bricks(30)  # 生成30个随机砖块

        # 随机生成一些墙
        self._generate_random_walls(10)  # 生成10个随机墙

        # 初始化默认出生点
        self._initialize_default_spawn_points()

    def _initialize_default_spawn_points(self):
        """初始化默认出生点，确保它们远离障碍物"""
        # 清空现有出生点
        self.spawn_points = []

        # 定义基本的四个角落出生点位置，远离墙体
        # 确保离边界墙足够远，防止卡墙
        wall_offset = self.grid_size * 2.5
        potential_points = [
            (wall_offset, wall_offset),  # 左上角
            (self.screen_width - wall_offset, wall_offset),  # 右上角
            (wall_offset, self.screen_height - wall_offset),  # 左下角
            (self.screen_width - wall_offset, self.screen_height - wall_offset)  # 右下角
        ]

        # 检查每个点是否安全（不与障碍物重叠），如果不安全则调整
        for point in potential_points:
            safe_point = self._find_safe_spawn_point(point[0], point[1])
            if safe_point:
                self.spawn_points.append(safe_point)

        # 如果没有找到足够的安全点，添加中心区域的点
        if len(self.spawn_points) < 4:
            center_x = self.screen_width / 2
            center_y = self.screen_height / 2
            for offset in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
                center_point = (center_x + offset[0] * 50, center_y + offset[1] * 50)
                safe_point = self._find_safe_spawn_point(center_point[0], center_point[1])
                if safe_point and safe_point not in self.spawn_points:
                    self.spawn_points.append(safe_point)
                    if len(self.spawn_points) >= 4:
                        break

    def _find_safe_spawn_point(self, base_x, base_y, max_attempts=20):
        """
        在基准点周围找到一个安全的出生点

        Args:
            base_x, base_y: 基准点坐标
            max_attempts: 最大尝试次数

        Returns:
            安全的出生点坐标，如果找不到则返回None
        """
        # 首先检查原始点是否安全
        if self._is_safe_spawn_location(base_x, base_y, TANK_WIDTH, TANK_HEIGHT):
            return (base_x, base_y)

        # 原始点不安全，开始在周围搜索
        search_radius = self.grid_size

        for attempt in range(max_attempts):
            # 增加搜索半径
            search_radius += self.grid_size * 0.5

            # 在当前半径范围内随机选择点
            angle = self.random.uniform(0, 2 * math.pi)
            distance = self.random.uniform(0, search_radius)
            x = base_x + distance * math.cos(angle)
            y = base_y + distance * math.sin(angle)

            # 确保点在地图边界内
            x = max(TANK_WIDTH, min(self.screen_width - TANK_WIDTH, x))
            y = max(TANK_HEIGHT, min(self.screen_height - TANK_HEIGHT, y))

            # 检查这个点是否安全
            if self._is_safe_spawn_location(x, y, TANK_WIDTH, TANK_HEIGHT):
                return (x, y)

        # 如果找不到安全点，返回None
        print(f"Warning: Could not find safe spawn point near ({base_x}, {base_y})")
        return None

    def _is_safe_spawn_location(self, x, y, width, height, margin=5):
        """
        检查给定位置是否适合坦克出生

        Args:
            x, y: 位置坐标（中心点）
            width, height: 实体尺寸
            margin: 额外边距

        Returns:
            如果位置安全返回True
        """
        # 创建稍微小一点的坦克碰撞盒
        # 减小安全检查的边距，确保出生点不会过于受限
        tank_rect = (
            x - width / 2,
            y - height / 2,
            width,
            height
        )

        # 检查是否与任何障碍物重叠
        for obstacle in self.obstacles:
            if DeterministicPhysics.check_collision(tank_rect, obstacle.rect):
                return False

        # 检查是否太靠近地图边缘
        if (x - width / 2 - margin < 0 or
                x + width / 2 + margin > self.screen_width or
                y - height / 2 - margin < 0 or
                y + height / 2 + margin > self.screen_height):
            return False

        # 安全点
        return True

    def _add_additional_spawn_points(self, count):
        """添加额外的出生点"""
        attempts = 0
        max_attempts = 100
        added = 0

        while added < count and attempts < max_attempts:
            attempts += 1

            # 随机选择地图上的一点
            x = self.random.randint(self.grid_size * 2, self.screen_width - self.grid_size * 2)
            y = self.random.randint(self.grid_size * 2, self.screen_height - self.grid_size * 2)

            # 检查是否安全，且距离现有出生点足够远
            if self._is_safe_spawn_location(x, y, TANK_WIDTH, TANK_HEIGHT):
                # 检查与现有出生点的距离
                too_close = False
                for point in self.spawn_points:
                    if DeterministicPhysics.distance((x, y), point) < TANK_WIDTH * 3:
                        too_close = True
                        break

                if not too_close:
                    self.spawn_points.append((x, y))
                    added += 1

    def load_map(self, map_name):
        """从文件加载地图"""
        map_path = os.path.join(MAPS_DIR, f"{map_name}.json")
        try:
            with open(map_path, 'r') as f:
                map_data = json.load(f)

            # 清空已有障碍物
            self.obstacles = []
            self.spawn_points = []

            # 加载障碍物
            for obstacle in map_data.get('obstacles', []):
                obstacle_type = obstacle.get('type')
                x, y = obstacle.get('x'), obstacle.get('y')
                width, height = obstacle.get('width', OBSTACLE_SIZE), obstacle.get('height', OBSTACLE_SIZE)

                if obstacle_type == 'wall':
                    self.obstacles.append(WallObstacle(x, y, width, height))
                elif obstacle_type == 'brick':
                    self.obstacles.append(BrickObstacle(x, y, width, height))

            # 加载出生点
            self.spawn_points = map_data.get('spawn_points', [])

            # 如果没有出生点或出生点不安全，重新生成
            if not self.spawn_points or not self._validate_spawn_points():
                self._initialize_default_spawn_points()

        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Error loading map {map_name}: {e}")
            # 如果加载失败，生成默认地图
            self.generate_default_map()

    def _validate_spawn_points(self):
        """验证所有出生点是否安全"""
        safe_points = []
        for point in self.spawn_points:
            x, y = point[0], point[1]
            if self._is_safe_spawn_location(x, y, TANK_WIDTH, TANK_HEIGHT):
                safe_points.append(point)
            else:
                # 尝试找到附近的安全点
                safe_point = self._find_safe_spawn_point(x, y)
                if safe_point:
                    safe_points.append(safe_point)

        # 更新出生点列表
        self.spawn_points = safe_points

        # 如果没有足够的安全点，返回False
        return len(self.spawn_points) >= 4

    def save_map(self, map_name):
        """保存地图到文件"""
        map_data = {
            'obstacles': [],
            'spawn_points': self.spawn_points
        }

        # 保存障碍物数据
        for obstacle in self.obstacles:
            obstacle_type = 'wall' if isinstance(obstacle, WallObstacle) else 'brick'
            map_data['obstacles'].append({
                'type': obstacle_type,
                'x': obstacle.x,
                'y': obstacle.y,
                'width': obstacle.width,
                'height': obstacle.height
            })

        # 确保地图目录存在
        os.makedirs(MAPS_DIR, exist_ok=True)

        # 保存到文件
        map_path = os.path.join(MAPS_DIR, f"{map_name}.json")
        with open(map_path, 'w') as f:
            json.dump(map_data, f, indent=4)

    def _create_boundaries(self):
        """创建地图边界墙"""
        wall_size = OBSTACLE_SIZE

        # 上边界
        for x in range(0, self.screen_width, wall_size):
            self.obstacles.append(WallObstacle(x, 0))

        # 下边界
        for x in range(0, self.screen_width, wall_size):
            self.obstacles.append(WallObstacle(x, self.screen_height - wall_size))

        # 左边界
        for y in range(wall_size, self.screen_height - wall_size, wall_size):
            self.obstacles.append(WallObstacle(0, y))

        # 右边界
        for y in range(wall_size, self.screen_height - wall_size, wall_size):
            self.obstacles.append(WallObstacle(self.screen_width - wall_size, y))

    def _generate_random_bricks(self, count):
        """随机生成砖块"""
        for _ in range(count):
            # 随机选择网格位置
            grid_x = self.random.randint(1, self.map_width - 2)
            grid_y = self.random.randint(1, self.map_height - 2)

            # 转换为像素坐标
            x = grid_x * self.grid_size
            y = grid_y * self.grid_size

            # 创建砖块
            self.obstacles.append(BrickObstacle(x, y))

    def _generate_random_walls(self, count):
        """随机生成墙"""
        for _ in range(count):
            # 随机选择网格位置
            grid_x = self.random.randint(1, self.map_width - 2)
            grid_y = self.random.randint(1, self.map_height - 2)

            # 转换为像素坐标
            x = grid_x * self.grid_size
            y = grid_y * self.grid_size

            # 创建墙
            self.obstacles.append(WallObstacle(x, y))

    def get_spawn_points(self):
        """获取所有可用的出生点位置"""
        if not self.spawn_points:
            self._initialize_default_spawn_points()
        return self.spawn_points

    def get_random_spawn_point(self, used_points=None):
        """
        获取一个随机出生点，避免与已使用的点重叠

        Args:
            used_points: 已经被使用的出生点列表，避免重复

        Returns:
            随机选择的出生点坐标元组 (x, y)
        """
        # 获取所有可用的出生点
        spawn_points = self.get_spawn_points()

        if used_points is None:
            used_points = []

        # 过滤掉已使用的出生点
        available_points = [point for point in spawn_points if point not in used_points]

        # 如果没有可用出生点，尝试创建新点
        if not available_points:
            # 选择一个已使用的点作为基准，寻找附近的安全位置
            base_point = used_points[-1] if used_points else (self.screen_width // 2, self.screen_height // 2)
            new_point = self._find_safe_spawn_point(base_point[0], base_point[1])

            if new_point:
                return new_point
            else:
                # 如果仍然找不到安全点，选择基准点并警告
                print("Warning: Using a potentially unsafe spawn point")
                return base_point

        # 从可用出生点中随机选择一个
        return self.random.choice(available_points)

    def _check_overlap(self, point, rect, margin=0):
        """
        检查点与矩形是否重叠（考虑边距）

        Args:
            point: 要检查的点 (x, y)
            rect: 矩形 (x, y, width, height)
            margin: 额外边距

        Returns:
            如果点与矩形（加上边距）重叠，返回True
        """
        x, y = point
        rx, ry, rw, rh = rect

        # 扩展矩形边界
        rx -= margin
        ry -= margin
        rw += 2 * margin
        rh += 2 * margin

        return (rx <= x <= rx + rw) and (ry <= y <= ry + rh)

    def update(self):
        """更新地图状态"""
        # 移除被销毁的障碍物
        obstacles_to_remove = []
        for obstacle in self.obstacles:
            if getattr(obstacle, 'destroyed', False):
                obstacles_to_remove.append(obstacle)

        for obstacle in obstacles_to_remove:
            try:
                self.obstacles.remove(obstacle)
            except ValueError:
                pass  # 如果障碍物已被移除，忽略错误

    def draw(self, surface):
        """绘制地图"""
        # 绘制背景
        surface.fill(COLOR_BLACK)

        # 绘制障碍物
        for obstacle in self.obstacles:
            obstacle.draw(surface)

    def get_obstacles_at(self, grid_x, grid_y):
        """获取指定网格位置的障碍物"""
        x = grid_x * self.grid_size
        y = grid_y * self.grid_size

        obstacles_at_position = []
        for obstacle in self.obstacles:
            if (obstacle.x == x and obstacle.y == y):
                obstacles_at_position.append(obstacle)

        return obstacles_at_position

    def clear_obstacles(self):
        """清空所有障碍物"""
        self.obstacles = []

    def add_obstacle(self, obstacle):
        """添加障碍物"""
        self.obstacles.append(obstacle)

    def remove_obstacle(self, obstacle):
        """移除障碍物"""
        if obstacle in self.obstacles:
            self.obstacles.remove(obstacle)

    def add_spawn_point(self, x, y):
        """添加出生点"""
        self.spawn_points.append((x, y))

    def get_size(self):
        """获取地图尺寸"""
        return (self.screen_width, self.screen_height)

文件名: client/game_engine/obstacle.py
文件内容
======================================================================
# obstacle.py
"""
障碍物类模块：定义游戏中各种障碍物对象
"""

import pygame
import math
import os
from common.constants import *
from common.utils import current_time_ms
from client.game_engine.particle_system import particle_system


class Obstacle:
    """障碍物基类"""

    def __init__(self, x, y, width, height, health=None):
        """初始化障碍物"""
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.health = health if health is not None else float('inf')
        self.max_health = self.health
        self.rect = (x, y, width, height)
        self.image = None
        self.destroyed = False

        # 受伤状态
        self.hit_time = 0
        self.hit_flash_duration = 500  # 受伤闪烁持续0.5秒
        self.is_hit = False
        self.alpha = 255  # 完全不透明
        self.flash_interval = 100  # 闪烁间隔(毫秒)
        self.last_flash_time = 0
        self.flash_state = False

        # 爆炸效果
        self.is_exploding = False
        self.explosion_start_time = 0
        self.explosion_duration = 800  # 爆炸动画持续0.8秒
        self.explosion_particle_group_id = None  # 存储粒子组ID

    def take_damage(self, damage):
        """受到伤害，返回是否销毁"""
        if self.destroyed or self.is_exploding:
            return True

        if self.health != float('inf'):
            self.health -= damage

            # 设置受伤状态
            self.is_hit = True
            self.hit_time = current_time_ms()

            if self.health <= 0:
                self.health = 0
                self.start_explosion()
                return True

        return False

    def start_explosion(self):
        """开始爆炸效果"""
        self.is_exploding = True
        self.explosion_start_time = current_time_ms()

        # 根据障碍物类型选择颜色
        debris_colors = []
        if isinstance(self, BrickObstacle):
            debris_colors = [COLOR_BROWN, (139, 69, 19), (160, 82, 45)]  # 棕色系
        else:
            debris_colors = [COLOR_GRAY, (100, 100, 100), (70, 70, 70)]  # 灰色系

        # 创建碎片粒子效果
        self.explosion_particle_group_id = particle_system.create_debris(
            x=self.x + self.width / 2,
            y=self.y + self.height / 2,
            color_palette=debris_colors,
            count=20,
            min_speed=0.5,
            max_speed=3,
            min_size=1,
            max_size=4,
            duration=self.explosion_duration,
            gravity=0.1
        )

    def update(self, delta_time):
        """更新障碍物状态"""
        current_time = current_time_ms()

        # 处理爆炸效果
        if self.is_exploding:
            elapsed = current_time - self.explosion_start_time
            if elapsed > self.explosion_duration:
                self.is_exploding = False
                self.destroyed = True
                self.explosion_particle_group_id = None
            # 粒子由粒子系统更新，不需要在这里更新

        # 处理受伤闪烁效果
        if self.is_hit and not self.destroyed and not self.is_exploding:
            elapsed = current_time - self.hit_time

            # 受伤闪烁效果结束
            if elapsed > self.hit_flash_duration:
                self.is_hit = False
                self.alpha = 255  # 恢复完全不透明
            else:
                # 控制闪烁频率
                if current_time - self.last_flash_time > self.flash_interval:
                    self.last_flash_time = current_time
                    self.flash_state = not self.flash_state

                # 设置透明度
                self.alpha = 150 if self.flash_state else 255

        # 低生命值持续闪烁
        if self.health != float(
                'inf') and self.health <= self.max_health * 0.3 and not self.is_hit and not self.is_exploding and not self.destroyed:
            if current_time - self.last_flash_time > self.flash_interval * 1.5:  # 低生命闪烁更慢
                self.last_flash_time = current_time
                self.flash_state = not self.flash_state

            # 设置较轻的闪烁效果
            self.alpha = 200 if self.flash_state else 255

    def draw(self, surface):
        """绘制障碍物"""
        if self.destroyed:
            return  # 已销毁，不绘制

        if self.is_exploding:
            # 爆炸粒子由粒子系统绘制，这里仅绘制淡出的障碍物
            elapsed_ratio = (current_time_ms() - self.explosion_start_time) / self.explosion_duration
            fade_alpha = int(255 * (1 - elapsed_ratio))
            if fade_alpha > 0 and self.image:
                image_copy = self.image.copy()
                image_copy.set_alpha(fade_alpha)
                surface.blit(image_copy, self.rect)
        else:
            # 绘制带透明度的障碍物
            if self.image:
                # 创建带透明度的图像副本
                image_copy = self.image.copy()
                image_copy.set_alpha(self.alpha)
                # 绘制
                surface.blit(image_copy, self.rect)
            else:
                # 如果没有图像，绘制一个简单的矩形
                rect_surface = pygame.Surface((self.width, self.height), pygame.SRCALPHA)
                rect_surface.fill((*pygame.Color(self.get_color())[:3], self.alpha))
                surface.blit(rect_surface, self.rect)

    def get_color(self):
        """获取障碍物颜色（子类覆盖）"""
        return COLOR_GRAY

    def get_position(self):
        """获取障碍物位置"""
        return (self.x, self.y)

    def get_size(self):
        """获取障碍物尺寸"""
        return (self.width, self.height)

    def get_center(self):
        """获取障碍物中心点"""
        return (self.x + self.width / 2, self.y + self.height / 2)

    def serialize(self):
        """将障碍物状态序列化为字典"""
        return {
            'type': self.__class__.__name__,
            'x': self.x,
            'y': self.y,
            'width': self.width,
            'height': self.height,
            'health': self.health,
            'destroyed': self.destroyed
        }


class WallObstacle(Obstacle):
    """不可破坏的墙"""

    def __init__(self, x, y, width=OBSTACLE_SIZE, height=OBSTACLE_SIZE):
        super().__init__(x, y, width, height, health=WALL_HEALTH)
        self.load_image()

    def load_image(self):
        """加载墙的图像"""
        try:
            image_path = os.path.join(IMAGES_DIR, "wall.png")
            if os.path.exists(image_path):
                self.image = pygame.image.load(image_path).convert_alpha()
                self.image = pygame.transform.scale(self.image, (self.width, self.height))
            else:
                # 如果图像文件不存在，创建一个简单的表面
                self.image = pygame.Surface((self.width, self.height))
                self.image.fill(COLOR_GRAY)
        except pygame.error as e:
            print(f"Error loading wall image: {e}")
            # 如果加载失败，创建一个默认图像
            self.image = pygame.Surface((self.width, self.height))
            self.image.fill(COLOR_GRAY)

    def get_color(self):
        return COLOR_GRAY


class BrickObstacle(Obstacle):
    """可破坏的砖墙"""

    def __init__(self, x, y, width=OBSTACLE_SIZE, height=OBSTACLE_SIZE):
        super().__init__(x, y, width, height, health=BRICK_HEALTH)
        self.load_image()

    def load_image(self):
        """加载砖墙的图像"""
        try:
            image_path = os.path.join(IMAGES_DIR, "brick.png")
            if os.path.exists(image_path):
                self.image = pygame.image.load(image_path).convert_alpha()
                self.image = pygame.transform.scale(self.image, (self.width, self.height))
            else:
                # 如果图像文件不存在，创建一个简单的表面
                self.image = pygame.Surface((self.width, self.height))
                self.image.fill(COLOR_BROWN)
        except pygame.error as e:
            print(f"Error loading brick image: {e}")
            # 如果加载失败，创建一个默认图像
            self.image = pygame.Surface((self.width, self.height))
            self.image.fill(COLOR_BROWN)

    def get_color(self):
        return COLOR_BROWN

文件名: client/game_engine/particle_system.py
文件内容
======================================================================
# particle_system.py
"""
粒子系统模块：用于创建和管理粒子效果
"""

import pygame
import math
import random
from common.constants import *
from common.utils import current_time_ms


class Particle:
    """单个粒子类"""

    def __init__(self, x, y, dx, dy, size, color, life_duration, gravity=0):
        """初始化粒子"""
        self.x = x
        self.y = y
        self.dx = dx  # x方向速度
        self.dy = dy  # y方向速度
        self.size = size  # 初始大小
        self.original_size = size  # 保存初始大小用于计算缩放
        self.color = color  # (r, g, b) 颜色元组
        self.creation_time = current_time_ms()
        self.life_duration = life_duration  # 生命周期(毫秒)
        self.gravity = gravity  # 重力影响
        self.alpha = 255  # 透明度
        self.active = True  # 粒子是否活跃

    def update(self, delta_time):
        """更新粒子状态"""
        if not self.active:
            return

        # 计算已过去时间
        current_time = current_time_ms()
        elapsed = current_time - self.creation_time

        # 检查是否超过生命周期
        if elapsed >= self.life_duration:
            self.active = False
            return

        # 计算生命周期比例(0-1之间)
        life_ratio = elapsed / self.life_duration

        # 更新位置
        seconds = delta_time  # 转换为秒
        self.x += self.dx * seconds * 60  # 速度标准化为60FPS
        self.y += self.dy * seconds * 60

        # 应用重力
        self.dy += self.gravity * seconds

        # 随着生命周期更新大小
        size_factor = 1.0 - life_ratio  # 线性缩小
        self.size = max(0.1, self.original_size * size_factor)

        # 随着生命周期更新透明度
        self.alpha = int(255 * (1.0 - life_ratio))

    def draw(self, surface):
        """绘制粒子"""
        if not self.active or self.size <= 0:
            return

        # 对于非常小的粒子，确保至少绘制1像素
        size = max(1, int(self.size))

        # 创建带有透明度的颜色
        color_with_alpha = (*self.color, self.alpha)

        # 创建表面并绘制粒子
        if size <= 1:
            # 单像素直接绘制
            surface.set_at((int(self.x), int(self.y)), color_with_alpha)
        else:
            # 创建带透明度的圆形粒子
            particle_surface = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)
            pygame.draw.circle(particle_surface, color_with_alpha, (size, size), size)
            surface.blit(particle_surface, (int(self.x - size), int(self.y - size)))


class ParticleSystem:
    """粒子系统类"""

    def __init__(self):
        """初始化粒子系统"""
        self.particle_groups = {}  # 存储多个粒子组，键为组ID
        self.next_group_id = 0  # 下一个可用的组ID

    def create_explosion(self, x, y, color_palette, count=30, min_speed=1, max_speed=5,
                         min_size=2, max_size=6, duration=1000, gravity=0):
        """
        创建爆炸效果

        Args:
            x, y: 爆炸中心坐标
            color_palette: 颜色列表，粒子将随机选择其中的颜色
            count: 粒子数量
            min_speed, max_speed: 粒子速度范围
            min_size, max_size: 粒子大小范围
            duration: 爆炸持续时间(毫秒)
            gravity: 重力系数，正值使粒子下落，负值使粒子上升

        Returns:
            粒子组ID，可用于检查效果是否完成
        """
        particles = []

        for _ in range(count):
            # 随机角度、速度和大小
            angle = random.uniform(0, 2 * math.pi)
            speed = random.uniform(min_speed, max_speed)
            size = random.randint(min_size, max_size)

            # 随机选择颜色
            color = random.choice(color_palette)

            # 计算速度向量
            dx = math.cos(angle) * speed
            dy = math.sin(angle) * speed

            # 创建粒子，生命周期随机化以增加多样性
            life = random.uniform(0.7, 1.0) * duration
            particle = Particle(x, y, dx, dy, size, color, life, gravity)
            particles.append(particle)

        # 将粒子组添加到系统中
        group_id = self.next_group_id
        self.particle_groups[group_id] = particles
        self.next_group_id += 1

        return group_id

    def create_debris(self, x, y, color_palette, count=15, min_speed=0.5, max_speed=3,
                      min_size=1, max_size=4, duration=800, gravity=0.1):
        """
        创建碎片效果，类似爆炸但带有重力

        参数同create_explosion，但默认值针对碎片效果进行了优化
        """
        return self.create_explosion(x, y, color_palette, count, min_speed, max_speed,
                                     min_size, max_size, duration, gravity)

    def create_spark(self, x, y, direction_angle, spread_angle=30, color_palette=None,
                     count=10, min_speed=3, max_speed=7, min_size=1, max_size=3, duration=500):
        """
        创建火花效果，在指定方向上喷射粒子

        Args:
            x, y: 火花起始坐标
            direction_angle: 火花方向角度(度)
            spread_angle: 扩散角度(度)，粒子将在direction_angle±spread_angle的范围内生成
            color_palette: 颜色列表，默认为红黄色系
            其他参数同create_explosion
        """
        if color_palette is None:
            color_palette = [COLOR_RED, COLOR_YELLOW, COLOR_ORANGE]

        particles = []

        for _ in range(count):
            # 计算随机角度(弧度)，在指定方向上扩散
            angle_offset = random.uniform(-spread_angle, spread_angle)
            angle_rad = math.radians(direction_angle + angle_offset)

            speed = random.uniform(min_speed, max_speed)
            size = random.uniform(min_size, max_size)

            # 随机选择颜色
            color = random.choice(color_palette)

            # 计算速度向量
            dx = math.cos(angle_rad) * speed
            dy = math.sin(angle_rad) * speed

            # 创建粒子，火花通常寿命较短
            life = random.uniform(0.5, 1.0) * duration
            particle = Particle(x, y, dx, dy, size, color, life)
            particles.append(particle)

        # 将粒子组添加到系统中
        group_id = self.next_group_id
        self.particle_groups[group_id] = particles
        self.next_group_id += 1

        return group_id

    def is_group_active(self, group_id):
        """检查粒子组是否仍然活跃"""
        if group_id not in self.particle_groups:
            return False

        # 如果组中有任何活跃粒子，则组是活跃的
        return any(particle.active for particle in self.particle_groups[group_id])

    def remove_group(self, group_id):
        """移除粒子组"""
        if group_id in self.particle_groups:
            del self.particle_groups[group_id]

    def update(self, delta_time):
        """更新所有粒子组"""
        # 记录要移除的不活跃组
        groups_to_remove = []

        for group_id, particles in self.particle_groups.items():
            # 更新每个粒子
            for particle in particles:
                particle.update(delta_time)

            # 过滤掉不活跃的粒子
            self.particle_groups[group_id] = [p for p in particles if p.active]

            # 如果组内没有活跃粒子，标记为移除
            if not self.particle_groups[group_id]:
                groups_to_remove.append(group_id)

        # 移除不活跃的组
        for group_id in groups_to_remove:
            self.remove_group(group_id)

    def draw(self, surface):
        """绘制所有粒子组"""
        for particles in self.particle_groups.values():
            for particle in particles:
                particle.draw(surface)


# 创建全局粒子系统实例
particle_system = ParticleSystem()

文件名: client/game_engine/tank.py
文件内容
======================================================================
# tank.py
"""
坦克类模块：定义游戏中坦克对象的属性和行为
"""

import pygame
import math
import os
from common.constants import *
from common.utils import vector_from_angle, current_time_ms, rect_from_center
from common.deterministic_engine import DeterministicPhysics
from client.game_engine.particle_system import particle_system


class Tank:
    """
    坦克类：表示游戏中的坦克对象

    主要功能：
    - 初始化坦克（位置、朝向、颜色等）
    - 坦克移动控制
    - 坦克射击
    - 处理伤害和碰撞
    - 绘制坦克
    """

    # 定义方向常量，与按键对应
    RIGHT = 0
    DOWN = 90
    LEFT = 180
    UP = 270

    def __init__(self, x, y, color, tank_id=None, is_player=False):
        """初始化坦克对象"""
        self.x = x
        self.y = y
        self.prev_x = x  # 存储前一帧位置
        self.prev_y = y  # 存储前一帧位置
        self.color = color
        self.tank_id = tank_id or f"tank_{id(self)}"
        self.is_player = is_player

        # 坦克属性
        self.width = TANK_WIDTH
        self.height = TANK_HEIGHT
        self.speed = TANK_SPEED
        self.rotation_speed = TANK_ROTATION_SPEED
        self.health = TANK_HEALTH
        self.max_health = TANK_HEALTH  # 添加最大生命值记录
        self.ammo = TANK_AMMO
        self.last_shot_time = 0
        self.reload_time = TANK_RELOAD_TIME

        # 方向和运动
        self.direction = self.RIGHT  # 初始朝右
        self.moving = False
        self.rotating = 0  # -1 左转, 0 不转, 1 右转

        # 加载坦克图像
        self.original_image = None
        self.image = None
        self.load_image()

        # 碰撞盒
        self.collision_margin = 0  # 移除任何额外边距
        self.rect = (
            x - self.width / 2,
            y - self.height / 2,
            self.width,
            self.height
        )
        self.collision_box = (
            x - self.width / 2,
            y - self.height / 2,
            self.width,
            self.height
        )

        # 受伤状态
        self.hit_time = 0
        self.hit_flash_duration = 1000  # 受伤闪烁持续1秒
        self.is_hit = False
        self.alpha = 255  # 完全不透明
        self.flash_interval = 100  # 闪烁间隔(毫秒)
        self.last_flash_time = 0
        self.flash_state = False

        # 爆炸效果
        self.is_exploding = False
        self.explosion_start_time = 0
        self.explosion_duration = 1000  # 爆炸动画持续1秒
        self.explosion_particle_group_id = None  # 存储粒子组ID
        self.is_destroyed = False

    def load_image(self):
        """加载坦克图像"""
        try:
            # 尝试加载图像，如果图像文件不存在，则创建一个简单的表面
            image_path = os.path.join(IMAGES_DIR, f"tank_{self.color}.png")
            if os.path.exists(image_path):
                self.original_image = pygame.image.load(image_path).convert_alpha()
                self.original_image = pygame.transform.scale(self.original_image, (self.width, self.height))
            else:
                # 创建简单的矩形表面
                self.original_image = pygame.Surface((self.width, self.height), pygame.SRCALPHA)

                # 绘制坦克主体（方形）
                tank_color = COLOR_RED if self.color == 'red' else COLOR_BLUE if self.color == 'blue' else COLOR_GREEN if self.color == 'green' else COLOR_YELLOW
                pygame.draw.rect(self.original_image, tank_color, (0, 0, self.width, self.height))

                # 绘制坦克炮塔（圆形）
                pygame.draw.circle(self.original_image, COLOR_DARK_GREEN,
                                   (self.width // 2, self.height // 2), self.width // 3)

                # 绘制坦克炮管（向右方向的矩形）
                pygame.draw.rect(self.original_image, COLOR_DARK_GREEN,
                                 (self.width // 2, self.height // 2 - 2, self.width // 2, 4))

            # 初始方向设为向右
            self.direction = self.RIGHT
            self.update_image()

        except pygame.error as e:
            print(f"Error loading tank image: {e}")
            # 如果加载失败，创建一个默认图像
            self.original_image = pygame.Surface((self.width, self.height), pygame.SRCALPHA)
            pygame.draw.rect(self.original_image, self.color, (0, 0, self.width, self.height))
            self.update_image()

    def update_image(self):
        """更新坦克图像的旋转"""
        # 将角度转换为旋转值，pygame旋转是逆时针的，我们需要负值
        self.image = pygame.transform.rotate(self.original_image, -self.direction)

        # 获取旋转后的矩形并确保中心点不变
        new_rect = self.image.get_rect(center=(self.x, self.y))

        # 注意：这里只更新图像的绘制矩形，不影响碰撞盒
        self.rect = (new_rect.x, new_rect.y, new_rect.width, new_rect.height)

        # 单独更新碰撞盒，保持碰撞盒为正方形
        self.collision_box = (
            self.x - self.width / 2,
            self.y - self.height / 2,
            self.width,
            self.height
        )

    def set_direction(self, direction):
        """设置坦克方向"""
        self.direction = direction
        self.update_image()

    def move_in_direction(self, direction, obstacles=None):
        """向指定方向移动坦克"""
        self.set_direction(direction)
        self.moving = True
        return self.move(obstacles=obstacles)

    def move(self, direction=None, obstacles=None):
        """移动坦克，处理碰撞"""
        if not self.moving or self.is_exploding or self.is_destroyed:
            return False

        # 保存当前位置，以便在碰撞时回退
        self.prev_x = self.x
        self.prev_y = self.y

        # 计算移动向量
        angle_rad = math.radians(self.direction)
        dx, dy = vector_from_angle(angle_rad, self.speed)

        # 先尝试更新位置
        new_x = self.x + dx
        new_y = self.y + dy

        # 边界检查，留出一点余量避免卡边界
        margin = 2
        new_x = max(self.width / 2 + margin, min(SCREEN_WIDTH - self.width / 2 - margin, new_x))
        new_y = max(self.height / 2 + margin, min(SCREEN_HEIGHT - self.height / 2 - margin, new_y))

        # 分别检查X和Y方向的移动，实现滑墙效果
        can_move_x = True
        can_move_y = True

        if obstacles:
            # 使用稍小的碰撞盒检查，允许坦克通过狭窄空间
            # 缩小的碰撞盒仅用于碰撞检测
            collision_shrink = 2  # 每边缩小的像素数

            # 检查X方向移动
            test_rect_x = (
                new_x - self.width / 2 + collision_shrink,
                self.y - self.height / 2 + collision_shrink,
                self.width - 2 * collision_shrink,
                self.height - 2 * collision_shrink
            )

            for obstacle in obstacles:
                if getattr(obstacle, 'destroyed', False):
                    continue
                if DeterministicPhysics.check_collision(test_rect_x, obstacle.rect):
                    can_move_x = False
                    break

            # 检查Y方向移动
            test_rect_y = (
                self.x - self.width / 2 + collision_shrink,
                new_y - self.height / 2 + collision_shrink,
                self.width - 2 * collision_shrink,
                self.height - 2 * collision_shrink
            )

            for obstacle in obstacles:
                if getattr(obstacle, 'destroyed', False):
                    continue
                if DeterministicPhysics.check_collision(test_rect_y, obstacle.rect):
                    can_move_y = False
                    break

        # 应用移动，考虑滑墙
        if can_move_x:
            self.x = new_x
        if can_move_y:
            self.y = new_y

        # 更新碰撞矩形和绘制矩形
        # 注意视觉表现的矩形和碰撞检测的矩形可能稍有不同
        self.update_image()  # 这会更新self.rect和self.collision_box

        # 确保碰撞盒也被更新
        self.collision_box = (
            self.x - self.width / 2,
            self.y - self.height / 2,
            self.width,
            self.height
        )

        return can_move_x or can_move_y  # 只要有一个方向能移动就返回True

    def can_shoot(self, current_time):
        """检查是否可以射击"""
        return (self.ammo > 0 and
                (current_time - self.last_shot_time) >= self.reload_time and
                not self.is_exploding and not self.is_destroyed)

    def shoot(self, current_time):
        """射击，返回子弹的初始位置和方向"""
        if not self.can_shoot(current_time):
            return None

        # 减少弹药
        self.ammo -= 1
        self.last_shot_time = current_time

        # 计算子弹的初始位置（坦克炮管前端）
        angle_rad = math.radians(self.direction)
        bullet_offset = vector_from_angle(angle_rad, self.width / 2)
        bullet_x = self.x + bullet_offset[0]
        bullet_y = self.y + bullet_offset[1]

        return (bullet_x, bullet_y, self.direction)

    def take_damage(self, damage):
        """受到伤害，返回是否死亡"""
        if self.is_exploding or self.is_destroyed:
            return True  # 已经在爆炸或已销毁

        self.health -= damage

        # 设置受伤状态
        self.is_hit = True
        self.hit_time = current_time_ms()
        self.flash_state = True  # 强制开始闪烁
        self.alpha = 128  # 立即应用透明度

        # 检查是否死亡
        if self.health <= 0:
            self.health = 0
            self.start_explosion()
            return True
        return False

    def show_collision_effect(self):
        """显示坦克碰撞效果"""
        # 轻微闪烁以指示碰撞
        self.is_hit = True
        self.hit_time = current_time_ms()
        self.hit_flash_duration = 300  # 短时间闪烁
        self.alpha = 180  # 稍微降低透明度

    def start_explosion(self):
        """开始爆炸效果"""
        self.is_exploding = True
        self.explosion_start_time = current_time_ms()

        # 创建爆炸粒子效果
        explosion_colors = [COLOR_RED, COLOR_YELLOW, COLOR_ORANGE]
        self.explosion_particle_group_id = particle_system.create_explosion(
            x=self.x,
            y=self.y,
            color_palette=explosion_colors,
            count=30,
            min_speed=1,
            max_speed=5,
            min_size=2,
            max_size=6,
            duration=self.explosion_duration
        )

        # 同时创建一些碎片效果
        debris_colors = []
        if self.color == 'red':
            debris_colors = [(200, 0, 0), (150, 0, 0), (100, 0, 0)]
        elif self.color == 'blue':
            debris_colors = [(0, 0, 200), (0, 0, 150), (0, 0, 100)]
        elif self.color == 'green':
            debris_colors = [(0, 200, 0), (0, 150, 0), (0, 100, 0)]
        elif self.color == 'yellow':
            debris_colors = [(200, 200, 0), (150, 150, 0), (100, 100, 0)]
        else:
            debris_colors = [COLOR_GRAY, COLOR_DARK_GREEN, COLOR_BROWN]

        particle_system.create_debris(
            x=self.x,
            y=self.y,
            color_palette=debris_colors,
            count=15,
            min_speed=0.5,
            max_speed=3,
            min_size=1,
            max_size=4,
            duration=800,
            gravity=0.1
        )

    def update(self, delta_time):
        """更新坦克状态"""
        current_time = current_time_ms()

        # 处理爆炸效果
        if self.is_exploding:
            elapsed = current_time - self.explosion_start_time
            if elapsed > self.explosion_duration:
                self.is_exploding = False
                self.is_destroyed = True
                self.explosion_particle_group_id = None
            # 粒子由粒子系统更新，不需要在这里更新

        # 处理受伤闪烁效果
        if self.is_hit:
            elapsed = current_time - self.hit_time

            # 受伤闪烁效果结束
            if elapsed > self.hit_flash_duration:
                self.is_hit = False
                self.alpha = 255  # 恢复完全不透明
            else:
                # 控制闪烁频率
                if current_time - self.last_flash_time > self.flash_interval:
                    self.last_flash_time = current_time
                    self.flash_state = not self.flash_state

                # 设置透明度
                self.alpha = 128 if self.flash_state else 255

        # 坦克生命值低时持续闪烁
        if self.health <= self.max_health * 0.3 and not self.is_hit and not self.is_exploding and not self.is_destroyed:
            if current_time - self.last_flash_time > self.flash_interval * 2:  # 低生命闪烁更慢
                self.last_flash_time = current_time
                self.flash_state = not self.flash_state

            # 设置较轻的闪烁效果
            self.alpha = 180 if self.flash_state else 255

    def draw(self, surface):
        """在屏幕上绘制坦克"""
        if self.is_destroyed:
            return  # 坦克已销毁，不绘制

        if self.is_exploding:
            # 爆炸粒子由粒子系统绘制，这里仅绘制淡出的坦克
            if self.image:
                # 计算淡出效果
                elapsed_ratio = min(1.0, (current_time_ms() - self.explosion_start_time) / self.explosion_duration)
                fade_alpha = int(255 * (1 - elapsed_ratio))

                if fade_alpha > 0:
                    # 创建带透明度的图像副本
                    image_copy = self.image.copy()
                    image_copy.set_alpha(fade_alpha)
                    surface.blit(image_copy, self.rect)
        else:
            # 绘制带透明度的坦克
            if self.image:
                # 创建带透明度的图像副本
                image_copy = self.image.copy()
                # 设置透明度
                image_copy.set_alpha(self.alpha)
                # 绘制
                surface.blit(image_copy, self.rect)
            else:
                # 如果没有图像，绘制一个简单的矩形
                rect_surface = pygame.Surface((self.width, self.height), pygame.SRCALPHA)
                rect_color = COLOR_RED if self.color == 'red' else COLOR_BLUE if self.color == 'blue' else COLOR_GREEN if self.color == 'green' else COLOR_YELLOW
                rect_surface.fill((*pygame.Color(rect_color)[:3], self.alpha))
                surface.blit(rect_surface, self.rect)

    def serialize(self):
        """将坦克状态序列化为字典"""
        return {
            'tank_id': self.tank_id,
            'x': self.x,
            'y': self.y,
            'direction': self.direction,
            'health': self.health,
            'ammo': self.ammo,
            'color': self.color,
            'is_player': self.is_player,
            'last_shot_time': self.last_shot_time,
            'is_destroyed': self.is_destroyed
        }

    @classmethod
    def deserialize(cls, data, color):
        """从序列化数据创建坦克"""
        tank = cls(
            x=data['x'],
            y=data['y'],
            color=data['color'] if 'color' in data else color,
            tank_id=data['tank_id'],
            is_player=data['is_player']
        )
        tank.direction = data['direction']
        tank.health = data['health']
        tank.ammo = data['ammo']
        tank.last_shot_time = data['last_shot_time']
        if 'is_destroyed' in data and data['is_destroyed']:
            tank.is_destroyed = True
        tank.update_image()  # 更新图像以反映新方向
        return tank

    def apply_input(self, input_data):
        """应用输入数据更新坦克状态"""
        if not input_data:
            return

        # 处理移动输入
        if 'movement' in input_data:
            movement = input_data['movement']

            if movement == 'up':
                self.set_direction(self.UP)
                self.moving = True
            elif movement == 'right':
                self.set_direction(self.RIGHT)
                self.moving = True
            elif movement == 'down':
                self.set_direction(self.DOWN)
                self.moving = True
            elif movement == 'left':
                self.set_direction(self.LEFT)
                self.moving = True
            elif movement == 'stop':
                self.moving = False

    def calculate_checksum(self):
        """计算坦克状态的校验和"""
        state = (
            self.x, self.y, self.direction, self.health,
            self.ammo, self.tank_id, self.moving
        )
        return hash(state)

文件名: client/network/client.py
文件内容
======================================================================
# client/network/client.py
import asyncio
import websockets
import json
import time
import random
import traceback


class NetworkClient:
    def __init__(self, game_client, server_url="ws://localhost:8766"):
        self.game_client = game_client
        self.server_url = server_url
        self.websocket = None
        self.connected = False
        self.client_id = None
        self.message_queue = asyncio.Queue()
        self.reconnect_interval = 1.0  # 重连间隔（秒）
        self.max_retries = 10  # 最大重试次数
        self.retry_count = 0

    async def connect_with_retry(self):
        """不断尝试连接到服务器，直到成功或达到最大重试次数"""
        if self.retry_count >= self.max_retries:
            print(f"[Client] Reached max retry attempts ({self.max_retries})")
            return False

        try:
            print(f"[Client] Connecting to {self.server_url} (attempt {self.retry_count + 1}/{self.max_retries})...")
            # 设置超时以避免长时间等待
            self.websocket = await asyncio.wait_for(
                websockets.connect(self.server_url),
                timeout=3.0
            )
            self.connected = True
            self.retry_count = 0  # 重置重试计数
            print(f"[Client] Connected to server successfully!")

            # 启动消息处理任务
            asyncio.create_task(self.receiver())
            asyncio.create_task(self.message_handler())

            return True
        except asyncio.TimeoutError:
            print(f"[Client] Connection timed out")
        except ConnectionRefusedError:
            print(f"[Client] Connection refused - server may not be running")
        except Exception as e:
            print(f"[Client] Connection error: {e}")
            print(f"[Client] Trace: {traceback.format_exc()}")

        self.retry_count += 1
        return False

    async def connect(self):
        """连接到游戏服务器（为保持兼容）"""
        return await self.connect_with_retry()

    async def disconnect(self):
        """断开与服务器的连接"""
        if self.websocket:
            await self.websocket.close()
            self.connected = False
            print("[Client] Disconnected from server")

    async def send_message(self, message):
        """发送消息到服务器"""
        if not self.connected:
            print("[Client] Can't send message - not connected")
            return False

        try:
            message_json = json.dumps(message)
            await self.websocket.send(message_json)
            return True
        except Exception as e:
            print(f"[Client] Send error: {e}")
            self.connected = False
            # 自动重连
            asyncio.create_task(self.reconnect())
            return False

    async def reconnect(self):
        """断线重连"""
        print("[Client] Attempting to reconnect...")
        self.connected = False
        self.retry_count = 0  # 重置重试计数
        await self.connect_with_retry()

    async def receiver(self):
        """接收服务器消息"""
        while self.connected and self.game_client.running:
            try:
                message = await self.websocket.recv()
                data = json.loads(message)
                await self.message_queue.put(data)
            except websockets.exceptions.ConnectionClosed:
                print(f"[Client] Connection closed by server")
                self.connected = False
                # 尝试重连
                asyncio.create_task(self.reconnect())
                break
            except Exception as e:
                print(f"[Client] Receive error: {e}")
                self.connected = False
                # 尝试重连
                asyncio.create_task(self.reconnect())
                break

    async def message_handler(self):
        """处理接收到的消息"""
        while self.connected and self.game_client.running:
            try:
                data = await self.message_queue.get()
                self.process_message(data)
                self.message_queue.task_done()
            except Exception as e:
                print(f"[Client] Message handling error: {e}")

    def process_message(self, data):
        """处理服务器消息"""
        msg_type = data.get('type')
        print(f"[Client] Received message type: {msg_type}")

        if msg_type == 'welcome':
            # 服务器欢迎消息，保存客户端ID
            self.client_id = data.get('client_id')
            print(f"[Client] Received client ID: {self.client_id}")

        elif msg_type == 'game_ready':
            # 游戏准备就绪
            players = data.get('players', 0)
            print(f"[Client] Game ready with {players} players")
            self.game_client.on_game_ready(players)

        elif msg_type == 'game_start':
            # 游戏开始
            start_time = data.get('start_time')
            players = data.get('players', 0)
            current_time = int(time.time() * 1000)
            print(f"[Client] Game will start at {start_time}, Current time: {current_time}, Delta: {start_time - current_time}ms")
            self.game_client.on_game_start(start_time, players)

        elif msg_type == 'input_frame':
            # 输入帧
            current_frame = data.get('current_frame')
            inputs = data.get('inputs', {})
            inputs_count = sum(len(frame_inputs) for client_id, frame_inputs in inputs.items() if isinstance(frame_inputs, dict))
            print(f"[Client] Received input frame for frame {current_frame}, inputs count: {inputs_count}")
            self.game_client.on_input_frame(current_frame, inputs)

    async def send_connect_request(self):
        """发送连接请求"""
        message = {
            'type': 'connect_request'
        }
        print("[Client] Sending connect request")
        await self.send_message(message)

    async def send_client_ready(self):
        """发送客户端就绪消息"""
        message = {
            'type': 'client_ready'
        }
        print("[Client] Sending client ready message")
        await self.send_message(message)

    async def send_input(self, frame, inputs):
        """发送输入到服务器"""
        message = {
            'type': 'input',
            'frame': frame,
            'inputs': inputs
        }
        await self.send_message(message)

文件名: client/network/protocol.py
文件内容
======================================================================
# client/network/protocol.py
"""
通信协议模块：定义客户端和服务器通信协议
"""

import json
import struct
from common.serialization import serialize_object, deserialize_object


class NetworkProtocol:
    """
    网络协议：处理消息的序列化和反序列化
    """

    @staticmethod
    def pack_message(message):
        """
        打包消息为二进制格式

        Args:
            message: 要打包的消息（字典）

        Returns:
            打包后的二进制数据
        """
        # 序列化消息到JSON
        msg_json = json.dumps(message)
        msg_bytes = msg_json.encode('utf-8')

        # 添加长度前缀（4字节网络字节序）
        msg_len = len(msg_bytes)
        prefix = struct.pack('!I', msg_len)

        return prefix + msg_bytes

    @staticmethod
    def unpack_message(data):
        """
        解包二进制数据为消息

        Args:
            data: 二进制数据

        Returns:
            解包后的消息（字典）
        """
        # 解析消息长度
        msg_len = struct.unpack('!I', data[:4])[0]

        # 解析消息内容
        msg_data = data[4:4 + msg_len].decode('utf-8')
        return json.loads(msg_data)

    @staticmethod
    def create_connect_message(client_id):
        """创建连接消息"""
        return {
            'type': 'connect',
            'client_id': client_id
        }

    @staticmethod
    def create_disconnect_message(client_id):
        """创建断开连接消息"""
        return {
            'type': 'disconnect',
            'client_id': client_id
        }

    @staticmethod
    def create_input_frame_message(client_id, frame_number, input_data):
        """创建输入帧消息"""
        return {
            'type': 'input_frame',
            'client_id': client_id,
            'frame': frame_number,
            'input': input_data,
            'timestamp': int(time.time() * 1000)
        }

    @staticmethod
    def create_state_sync_request_message(client_id, frame_number):
        """创建状态同步请求消息"""
        return {
            'type': 'request_state_sync',
            'client_id': client_id,
            'frame': frame_number,
            'timestamp': int(time.time() * 1000)
        }

文件名: client/ui/hud.py
文件内容
======================================================================
# hud.py
"""
游戏HUD模块：显示游戏中的状态信息
"""


class HUD:
    """
    HUD类：显示游戏中的状态信息

    主要功能：
    - 显示玩家生命值
    - 显示弹药数量
    - 显示游戏计分
    - 显示网络状态
    - 显示帧同步信息
    """

    def __init__(self, width, height):
        """初始化HUD"""
        pass

    def update(self, player_tank, game_state, network_stats):
        """更新HUD信息"""
        pass

    def draw(self, surface):
        """绘制HUD"""
        pass

    def show_message(self, message, duration=3000):
        """显示临时消息"""
        pass

    def show_game_over(self, winner=None):
        """显示游戏结束信息"""
        pass

    def show_network_stats(self, surface, current_frame, buffer_size, ping):
        """显示网络和帧同步统计信息"""
        pass

    def show_sync_warning(self, sync_status):
        """显示同步警告信息"""
        pass


# 单元测试
def test_hud():
    """HUD模块的单元测试"""
    pass


if __name__ == "__main__":
    test_hud()

文件名: client/ui/menu.py
文件内容
======================================================================
# menu.py
"""
游戏菜单模块：处理游戏菜单和用户界面
"""


class Menu:
    """
    菜单基类：所有菜单的基类

    主要功能：
    - 显示菜单项
    - 处理用户输入
    - 触发菜单事件
    """

    def __init__(self, title, options=None):
        """初始化菜单"""
        pass

    def add_option(self, text, callback):
        """添加菜单选项"""
        pass

    def handle_event(self, event):
        """处理用户输入事件"""
        pass

    def update(self):
        """更新菜单状态"""
        pass

    def draw(self, surface):
        """绘制菜单"""
        pass


class MainMenu(Menu):
    """
    主菜单：游戏的主菜单

    功能：
    - 开始游戏
    - 加入游戏
    - 设置
    - 退出
    """

    def __init__(self):
        """初始化主菜单"""
        pass


class LobbyMenu(Menu):
    """
    游戏大厅菜单：显示可用游戏房间

    功能：
    - 查看房间列表
    - 加入房间
    - 创建房间
    - 返回主菜单
    """

    def __init__(self, room_list=None):
        """初始化游戏大厅菜单"""
        pass

    def update_room_list(self, room_list):
        """更新房间列表"""
        pass


class PauseMenu(Menu):
    """
    暂停菜单：游戏暂停时显示

    功能：
    - 继续游戏
    - 设置
    - 退出游戏
    """

    def __init__(self):
        """初始化暂停菜单"""
        pass


# 单元测试
def test_menu():
    """菜单模块的单元测试"""
    pass


if __name__ == "__main__":
    test_menu()

文件名: client/main.py
文件内容
======================================================================
# client/main.py
import pygame
import sys
import asyncio
import time
from common.constants import *
from common.utils import current_time_ms
from client.game_engine.tank import Tank
from client.game_engine.bullet import Bullet
from client.game_engine.map import Map
from client.game_engine.particle_system import particle_system
from client.frame_sync.input_manager import InputManager
from client.frame_sync.frame_executor import FrameExecutor
from client.network.client import NetworkClient


class GameClient:
    def __init__(self):
        """初始化游戏客户端"""
        # 初始化pygame
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Tank Battle - Multiplayer")
        self.clock = pygame.time.Clock()

        # 游戏状态
        self.running = False
        self.paused = False
        self.game_state = STATE_MENU
        self.waiting_for_connection = False
        self.game_ready = False
        self.game_start_time = 0
        self.players_count = 0

        # 加载状态
        self.loading_progress = 0
        self.loading_complete = False

        # 帧同步组件
        self.input_manager = InputManager()
        self.frame_executor = FrameExecutor(self)
        server_url = "ws://localhost:8766"
        print(f"[Client] Initializing with server URL: {server_url}")
        self.network_client = NetworkClient(self, server_url)

        # 游戏对象
        self.map = None
        self.player_tank = None
        self.enemy_tanks = []
        self.bullets = []

        # 字体
        self.font = pygame.font.SysFont(None, 36)
        self.small_font = pygame.font.SysFont(None, 24)

    async def start(self):
        """启动游戏客户端"""
        self.running = True
        self.game_state = STATE_MENU

        # 连接到服务器
        self.waiting_for_connection = True
        asyncio.create_task(self.attempt_connection())

        # 进入游戏循环
        await self.game_loop()

    async def attempt_connection(self):
        """尝试连接到服务器"""
        while self.waiting_for_connection and self.running:
            connected = await self.network_client.connect_with_retry()
            if connected:
                print("[Client] Connected to server")
                break
            await asyncio.sleep(1)  # 避免过于频繁的连接尝试

    def on_game_ready(self, players):
        """处理游戏准备就绪信号"""
        print(f"[Client] Received game_ready with {players} players")
        self.game_ready = True
        self.waiting_for_connection = False
        self.players_count = players

        # 转换到加载状态
        self.game_state = STATE_LOADING
        print(f"[Client] Changed state to LOADING")

        # 开始异步加载资源
        asyncio.create_task(self.load_game_resources())

    async def load_game_resources(self):
        """异步加载游戏资源"""
        # 模拟资源加载过程
        total_steps = 10
        for i in range(total_steps):
            self.loading_progress = (i + 1) / total_steps
            print(f"[Client] Loading progress: {self.loading_progress * 100:.0f}%")
            await asyncio.sleep(0.1)  # 模拟加载延迟

        # 加载完成
        self.loading_complete = True
        print(f"[Client] Loading complete, sending client_ready")

        # 发送客户端准备就绪消息
        await self.network_client.send_client_ready()

    def on_game_start(self, start_time, players):
        """处理游戏开始信号"""
        print(f"[Client] Received game_start with start_time={start_time}, players={players}")
        self.game_start_time = start_time
        self.players_count = players

        # 初始化游戏，但不立即切换状态
        self.initialize_game()

        current_time = int(time.time() * 1000)
        time_until_start = start_time - current_time
        print(f"[Client] Game will start in {time_until_start}ms")

    def update(self):
        """游戏主更新循环（在game_loop中调用）"""
        current_time = int(time.time() * 1000)

        # 检查游戏是否应该开始
        if self.game_start_time > 0 and current_time >= self.game_start_time and self.game_state != STATE_PLAYING:
            print(f"[Client] Start time reached! Changing state to PLAYING")
            self.game_state = STATE_PLAYING

        # 只有在游戏状态且非暂停时才执行帧逻辑
        if self.game_state == STATE_PLAYING and not self.paused:
            # 捕获输入并发送给服务器
            inputs = self.input_manager.capture_input()
            if self.input_manager.has_input_changed():
                current_frame = self.frame_executor.current_frame
                print(f"[Client] Sending input for frame {current_frame}: {inputs}")
                asyncio.create_task(self.network_client.send_input(current_frame, inputs))

            # 执行当前帧
            frame_executed = self.frame_executor.execute_frame()
            if not frame_executed:
                print(f"[Client] Frame {self.frame_executor.current_frame} execution paused, waiting for input")

    def on_input_frame(self, frame, inputs):
        """处理输入帧"""
        self.frame_executor.add_input_frame(frame, inputs)

    def initialize_game(self):
        """初始化游戏状态"""
        # 加载地图
        self.map = Map()
        self.map.generate_random_map(seed=42)  # 使用固定种子确保所有客户端生成相同地图

        # 创建坦克等游戏对象
        # 注意：实际实现中应该由服务器分配坦克位置和ID
        # 这里简化处理，仅用于示例
        spawn_points = self.map.get_spawn_points()
        if spawn_points:
            self.player_tank = Tank(spawn_points[0][0], spawn_points[0][1], 'blue', tank_id="player", is_player=True)
        else:
            print("[Client ERROR] No spawn points found!")
            self.player_tank = Tank(100, 100, 'blue', tank_id="player", is_player=True)

        # 重置游戏状态
        self.bullets = []
        self.enemy_tanks = []

        print(f"[Client] Game initialized, waiting for start time")

    def update_game_state(self):
        """更新游戏状态（由帧执行器调用）"""
        # 更新粒子系统
        particle_system.update(1 / 60)

        # 更新坦克
        if self.player_tank:
            self.player_tank.update(1 / 60)

        for tank in self.enemy_tanks:
            tank.update(1 / 60)

        # 更新子弹
        current_bullets = []
        for bullet in self.bullets:
            hit_type, hit_obj = bullet.update(1 / 60, self.map.obstacles if self.map else [],
                                              [self.player_tank] + self.enemy_tanks if self.player_tank else [])
            if bullet.active:
                current_bullets.append(bullet)

        self.bullets = current_bullets

    def handle_tank_shoot(self, tank):
        """处理坦克射击"""
        current_time = current_time_ms()
        bullet_info = tank.shoot(current_time)

        if bullet_info:
            bullet_x, bullet_y, direction = bullet_info
            bullet = Bullet((bullet_x, bullet_y), direction, tank.tank_id)
            self.bullets.append(bullet)

    def render(self):
        """渲染游戏画面"""
        # 清屏
        self.screen.fill(COLOR_BLACK)

        if self.game_state == STATE_MENU:
            self._draw_menu()
        elif self.game_state == STATE_LOADING:
            self._draw_loading()
        elif self.game_state == STATE_PLAYING:
            self._draw_game()

        pygame.display.flip()

    def _draw_menu(self):
        """绘制菜单画面"""
        # 绘制标题
        title_text = self.font.render("Tank Battle - Multiplayer", True, COLOR_WHITE)
        self.screen.blit(title_text, (SCREEN_WIDTH / 2 - title_text.get_width() / 2, 100))

        if self.waiting_for_connection:
            # 连接中
            connecting_text = self.font.render("Connecting to server...", True, COLOR_WHITE)
            self.screen.blit(connecting_text, (SCREEN_WIDTH / 2 - connecting_text.get_width() / 2, 200))
        else:
            # 未知状态
            status_text = self.font.render("Waiting for server response...", True, COLOR_WHITE)
            self.screen.blit(status_text, (SCREEN_WIDTH / 2 - status_text.get_width() / 2, 200))

    def _draw_loading(self):
        """绘制加载画面"""
        # 绘制标题
        title_text = self.font.render("Loading Game...", True, COLOR_WHITE)
        self.screen.blit(title_text, (SCREEN_WIDTH / 2 - title_text.get_width() / 2, 100))

        # 绘制玩家数量
        players_text = self.font.render(f"Players in game: {self.players_count}", True, COLOR_WHITE)
        self.screen.blit(players_text, (SCREEN_WIDTH / 2 - players_text.get_width() / 2, 150))

        # 绘制进度条背景
        progress_bar_width = 400
        progress_bar_height = 30
        progress_bar_x = SCREEN_WIDTH / 2 - progress_bar_width / 2
        progress_bar_y = 250
        pygame.draw.rect(self.screen, COLOR_WHITE,
                         (progress_bar_x, progress_bar_y, progress_bar_width, progress_bar_height), 2)

        # 绘制进度条
        filled_width = int(progress_bar_width * self.loading_progress)
        if filled_width > 0:
            pygame.draw.rect(self.screen, COLOR_GREEN,
                             (progress_bar_x, progress_bar_y, filled_width, progress_bar_height))

        # 绘制进度文本
        progress_text = self.font.render(f"{self.loading_progress * 100:.0f}%", True, COLOR_WHITE)
        self.screen.blit(progress_text, (SCREEN_WIDTH / 2 - progress_text.get_width() / 2, 300))

        # 如果加载完成但还在等待游戏开始
        if self.loading_complete and self.game_start_time > 0:
            current_time = int(time.time() * 1000)
            if current_time < self.game_start_time:
                remaining_ms = self.game_start_time - current_time
                remaining_seconds = max(0, remaining_ms // 1000 + 1)
                waiting_text = self.font.render(f"Starting in {remaining_seconds} seconds...", True, COLOR_WHITE)
                self.screen.blit(waiting_text, (SCREEN_WIDTH / 2 - waiting_text.get_width() / 2, 350))
            else:
                starting_text = self.font.render("Starting now...", True, COLOR_WHITE)
                self.screen.blit(starting_text, (SCREEN_WIDTH / 2 - starting_text.get_width() / 2, 350))

    def _draw_game(self):
        """绘制游戏画面"""
        # 绘制地图
        if self.map:
            self.map.draw(self.screen)

        # 绘制坦克
        if self.player_tank:
            self.player_tank.draw(self.screen)

        for tank in self.enemy_tanks:
            tank.draw(self.screen)

        # 绘制子弹
        for bullet in self.bullets:
            bullet.draw(self.screen)

        # 绘制粒子
        particle_system.draw(self.screen)

        # 添加诊断信息
        self._draw_diagnostics()

    def _draw_diagnostics(self):
        """绘制诊断信息"""
        debug_font = self.small_font
        debug_y = 10
        debug_x = 10
        debug_color = COLOR_WHITE

        # 基本状态信息
        debug_texts = [
            f"Game State: {self.game_state}",
            f"Frame: {self.frame_executor.current_frame}",
            f"Waiting: {self.frame_executor.waiting_for_input}",
            f"Players: {self.players_count}",
            f"Buffer Size: {len(self.frame_executor.input_buffer)}"
        ]

        # 绘制所有文本
        for text in debug_texts:
            text_surface = debug_font.render(text, True, debug_color)
            self.screen.blit(text_surface, (debug_x, debug_y))
            debug_y += 20

    async def handle_events(self):
        """处理游戏事件和用户输入"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
                elif event.key == pygame.K_p and self.game_state == STATE_PLAYING:
                    self.paused = not self.paused

        # 如果游戏已经开始，捕获并发送输入
        if self.game_state == STATE_PLAYING and not self.paused:
            self.input_manager.capture_input()

    async def game_loop(self):
        """游戏主循环"""
        while self.running:
            # 处理事件
            await self.handle_events()

            # 更新游戏状态
            self.update()

            # 渲染
            self.render()

            # 控制帧率
            self.clock.tick(FPS)
            await asyncio.sleep(0)  # 让出控制权给其他协程

        # 游戏结束，断开连接
        await self.network_client.disconnect()
        pygame.quit()


# 主入口
def main():
    client = GameClient()
    asyncio.run(client.start())


if __name__ == "__main__":
    main()

文件名: common/constants.py
文件内容
======================================================================
# constants.py
"""
常量定义模块：定义游戏中使用的常量
"""

# 游戏常量
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60
TICK_RATE = 30  # 游戏逻辑更新率
FRAME_RATE = 60  # 网络帧同步率（与FPS保持一致）
TURN_SIZE = 6    # 每个回合包含的帧数（每隔多少帧同步一次）

# 游戏目录
RESOURCES_DIR = "resources"
IMAGES_DIR = f"{RESOURCES_DIR}/images"
SOUNDS_DIR = f"{RESOURCES_DIR}/sounds"
MAPS_DIR = f"{RESOURCES_DIR}/maps"

# 坦克常量
TANK_SPEED = 5  # 提高坦克速度，从3增加到5
TANK_ROTATION_SPEED = 3
TANK_HEALTH = 100
TANK_AMMO = 999999
TANK_RELOAD_TIME = 300  # 毫秒
TANK_WIDTH = 40
TANK_HEIGHT = 40

# 子弹常量
BULLET_SPEED = 15
BULLET_DAMAGE = 20
BULLET_LIFETIME = 5  # 秒
BULLET_RADIUS = 4

# 障碍物常量
WALL_HEALTH = float('inf')  # 不可破坏
BRICK_HEALTH = 50
OBSTACLE_SIZE = 40  # 默认障碍物尺寸

# 粒子系统常量
PARTICLE_MAX_COUNT = 2000  # 最大粒子数量限制
EXPLOSION_PARTICLE_COUNT = 30
DEBRIS_PARTICLE_COUNT = 20
SPARK_PARTICLE_COUNT = 10

# 颜色
COLOR_BLACK = (0, 0, 0)
COLOR_WHITE = (255, 255, 255)
COLOR_RED = (255, 0, 0)
COLOR_GREEN = (0, 255, 0)
COLOR_BLUE = (0, 0, 255)
COLOR_YELLOW = (255, 255, 0)
COLOR_GRAY = (128, 128, 128)
COLOR_DARK_GREEN = (0, 100, 0)
COLOR_BROWN = (165, 42, 42)
COLOR_ORANGE = (255, 165, 0)
COLOR_PURPLE = (128, 0, 128)
COLOR_PINK = (255, 192, 203)
COLOR_LIGHT_BLUE = (173, 216, 230)
COLOR_DARK_RED = (139, 0, 0)

# 方向常量
DIRECTION_UP = 0
DIRECTION_RIGHT = 1
DIRECTION_DOWN = 2
DIRECTION_LEFT = 3

# 地图常量
MAP_WIDTH = 20  # 地图宽度（以格子数计）
MAP_HEIGHT = 15  # 地图高度（以格子数计）
GRID_SIZE = 40   # 每个格子的大小（像素）

# 游戏事件类型
EVENT_HIT = 1
EVENT_DESTROY = 2
EVENT_GAME_START = 3
EVENT_GAME_END = 4

# 游戏状态
STATE_MENU = 0
STATE_LOADING = 1  # 新增 Loading 状态
STATE_PLAYING = 2  # 由于新增了 LOADING 状态，所以 PLAYING 状态的值变为 2
STATE_PAUSED = 3   # 后续状态值也相应调整
STATE_GAME_OVER = 4

# 游戏模式
MODE_SINGLE_PLAYER = 0
MODE_TWO_PLAYER = 1
MODE_NETWORK = 2

# UI常量
UI_BUTTON_WIDTH = 200
UI_BUTTON_HEIGHT = 50
UI_BUTTON_PADDING = 20
UI_FONT_SIZE = 36
UI_FONT_COLOR = COLOR_WHITE
UI_BUTTON_COLOR = (80, 80, 80)
UI_BUTTON_HOVER_COLOR = (100, 100, 100)
UI_BUTTON_TEXT_COLOR = COLOR_WHITE

# 音效音量
SOUND_VOLUME = 0.5
MUSIC_VOLUME = 0.3

# 网络相关常量
DEFAULT_SERVER_PORT = 8766
DEFAULT_SERVER_HOST = "localhost"
CONNECTION_TIMEOUT = 5000  # 连接超时（毫秒）
RECONNECT_INTERVAL = 1000  # 重连间隔（毫秒）
MIN_PLAYERS = 2  # 最小所需玩家数
MAX_PLAYERS = 4  # 最大支持玩家数

# 网络游戏状态常量
GAME_STATE_WAITING = "waiting"
GAME_STATE_READY = "ready"
GAME_STATE_LOADING = "loading"  # 新增加载状态
GAME_STATE_PLAYING = "playing"
GAME_STATE_PAUSED = "paused"
GAME_STATE_ENDED = "ended"

# 网络调试配置
NETWORK_DEBUG_MODE = True  # 网络调试模式

文件名: common/deterministic_engine.py
文件内容
======================================================================
# deterministic_engine.py
"""
确定性引擎模块：提供可重现的随机数生成和物理计算

这个模块确保在相同的种子和输入条件下，游戏的随机元素和物理计算
始终产生相同的结果，有助于游戏回放和网络同步。
"""

import random
import math


class DeterministicRandom:
    """
    确定性随机数生成器

    使用固定的种子和算法确保在相同种子下产生相同的随机序列。
    用于地图生成、AI决策等需要可重现随机性的场景。
    """

    def __init__(self, seed=None):
        """初始化随机数生成器，可选指定种子"""
        self._random = random.Random()
        self.seed(seed)

    def seed(self, seed=None):
        """设置随机数生成器的种子"""
        self._random.seed(seed)
        return seed

    def random(self):
        """返回 [0.0, 1.0) 范围内的随机浮点数"""
        return self._random.random()

    def uniform(self, a, b):
        """返回 [a, b) 范围内的随机浮点数"""
        return self._random.uniform(a, b)

    def randint(self, a, b):
        """返回 [a, b] 范围内的随机整数"""
        return self._random.randint(a, b)

    def choice(self, seq):
        """从非空序列中随机选择一个元素"""
        return self._random.choice(seq)

    def choices(self, population, weights=None, k=1):
        """从population中随机选择k个元素，可以指定权重"""
        return self._random.choices(population, weights, k=k)

    def shuffle(self, x):
        """将序列x随机打乱"""
        return self._random.shuffle(x)

    def sample(self, population, k):
        """从population中随机抽取k个不重复的元素"""
        return self._random.sample(population, k)

    def randrange(self, start, stop=None, step=1):
        """返回range(start, stop, step)中的随机元素"""
        return self._random.randrange(start, stop, step)

    def normalvariate(self, mu, sigma):
        """返回均值为mu，标准差为sigma的正态分布随机数"""
        return self._random.normalvariate(mu, sigma)


class DeterministicPhysics:
    """
    确定性物理计算

    提供确定性的物理计算函数，确保相同输入产生相同输出。
    用于碰撞检测、移动计算等需要精确可重现的场景。
    """

    @staticmethod
    def check_collision(rect1, rect2):
        """
        检查两个矩形是否碰撞

        Args:
            rect1: 第一个矩形 (x, y, width, height)
            rect2: 第二个矩形 (x, y, width, height)

        Returns:
            如果两个矩形重叠，返回True
        """
        x1, y1, w1, h1 = rect1
        x2, y2, w2, h2 = rect2

        # 检查两个矩形是否不重叠
        if (x1 >= x2 + w2 or  # rect1在rect2右侧
                x1 + w1 <= x2 or  # rect1在rect2左侧
                y1 >= y2 + h2 or  # rect1在rect2下方
                y1 + h1 <= y2):  # rect1在rect2上方
            return False

        return True

    @staticmethod
    def check_circle_collision(circle1, circle2):
        """
        检查两个圆是否碰撞

        Args:
            circle1: 第一个圆 (x, y, radius)
            circle2: 第二个圆 (x, y, radius)

        Returns:
            如果两个圆重叠，返回True
        """
        x1, y1, r1 = circle1
        x2, y2, r2 = circle2

        # 计算两个圆心之间的距离
        distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

        # 如果距离小于两个半径之和，则圆重叠
        return distance < (r1 + r2)

    @staticmethod
    def check_circle_rect_collision(circle, rect):
        """
        检查圆与矩形是否碰撞

        Args:
            circle: 圆 (x, y, radius)
            rect: 矩形 (x, y, width, height)

        Returns:
            如果圆与矩形重叠，返回True
        """
        circle_x, circle_y, radius = circle
        rect_x, rect_y, rect_w, rect_h = rect

        # 找到矩形上离圆心最近的点
        closest_x = max(rect_x, min(circle_x, rect_x + rect_w))
        closest_y = max(rect_y, min(circle_y, rect_y + rect_h))

        # 计算圆心到矩形最近点的距离
        distance = math.sqrt((circle_x - closest_x) ** 2 + (circle_y - closest_y) ** 2)

        # 如果距离小于圆的半径，则相交
        return distance < radius

    @staticmethod
    def calculate_reflection(direction, normal):
        """
        计算反射方向

        Args:
            direction: 入射方向向量 (dx, dy)
            normal: 表面法线向量 (nx, ny)，应该是单位向量

        Returns:
            反射方向向量 (reflect_dx, reflect_dy)
        """
        dx, dy = direction
        nx, ny = normal

        # 确保法线是单位向量
        norm = math.sqrt(nx * nx + ny * ny)
        if norm != 0:
            nx /= norm
            ny /= norm

        # 计算入射方向与法线的点积
        dot_product = dx * nx + dy * ny

        # 计算反射方向 (r = d - 2(d·n)n)
        reflect_dx = dx - 2 * dot_product * nx
        reflect_dy = dy - 2 * dot_product * ny

        return (reflect_dx, reflect_dy)

    @staticmethod
    def get_rect_center(rect):
        """
        获取矩形的中心点

        Args:
            rect: 矩形 (x, y, width, height)

        Returns:
            中心点坐标 (center_x, center_y)
        """
        x, y, width, height = rect
        return (x + width / 2, y + height / 2)

    @staticmethod
    def vector_magnitude(vector):
        """
        计算向量的大小

        Args:
            vector: 向量 (x, y)

        Returns:
            向量的大小
        """
        return math.sqrt(vector[0] ** 2 + vector[1] ** 2)

    @staticmethod
    def vector_normalize(vector):
        """
        将向量归一化为单位向量

        Args:
            vector: 向量 (x, y)

        Returns:
            归一化后的向量 (nx, ny)，如果向量为零向量，则返回 (0, 0)
        """
        magnitude = DeterministicPhysics.vector_magnitude(vector)
        if magnitude == 0:
            return (0, 0)
        return (vector[0] / magnitude, vector[1] / magnitude)

    @staticmethod
    def distance(point1, point2):
        """
        计算两点之间的距离

        Args:
            point1: 第一个点 (x, y)
            point2: 第二个点 (x, y)

        Returns:
            两点之间的欧几里得距离
        """
        return math.sqrt((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2)

    @staticmethod
    def angle_between_points(point1, point2):
        """
        计算从point1到point2的角度（弧度）

        Args:
            point1: 起点 (x, y)
            point2: 终点 (x, y)

        Returns:
            从point1到point2的角度，以弧度计，0表示向右，π/2表示向下
        """
        return math.atan2(point2[1] - point1[1], point2[0] - point1[0])

    @staticmethod
    def angle_to_vector(angle):
        """
        将角度转换为单位向量

        Args:
            angle: 角度，以弧度计

        Returns:
            对应的单位向量 (x, y)
        """
        return (math.cos(angle), math.sin(angle))

    @staticmethod
    def vector_to_angle(vector):
        """
        将向量转换为角度

        Args:
            vector: 向量 (x, y)

        Returns:
            向量的角度，以弧度计，范围在 [-π, π]
        """
        return math.atan2(vector[1], vector[0])

    @staticmethod
    def rotate_point(point, center, angle):
        """
        围绕中心点旋转一个点

        Args:
            point: 要旋转的点 (x, y)
            center: 旋转中心 (x, y)
            angle: 旋转角度，以弧度计，正值表示逆时针旋转

        Returns:
            旋转后的点 (x', y')
        """
        # 将点相对于中心点平移
        x, y = point[0] - center[0], point[1] - center[1]

        # 应用旋转
        cos_a, sin_a = math.cos(angle), math.sin(angle)
        x_new = x * cos_a - y * sin_a
        y_new = x * sin_a + y * cos_a

        # 平移回原来的坐标系
        return (x_new + center[0], y_new + center[1])

文件名: common/events.py
文件内容
======================================================================
# events.py
"""
事件系统模块：处理游戏事件
"""


class Event:
    """
    事件基类：所有游戏事件的基类

    主要功能：
    - 存储事件类型和数据
    - 序列化和反序列化
    """

    def __init__(self, event_type, data=None):
        """初始化事件"""
        pass

    def serialize(self):
        """将事件序列化为字典"""
        pass

    @classmethod
    def deserialize(cls, data):
        """从序列化数据创建事件"""
        pass


class HitEvent(Event):
    """击中事件：表示子弹击中目标"""

    def __init__(self, bullet_id, target_id, damage):
        """初始化击中事件"""
        pass


class DestroyEvent(Event):
    """摧毁事件：表示对象被摧毁"""

    def __init__(self, object_id, object_type):
        """初始化摧毁事件"""
        pass


class GameStartEvent(Event):
    """游戏开始事件"""

    def __init__(self, room_id, players, map_seed):
        """初始化游戏开始事件"""
        pass


class GameEndEvent(Event):
    """游戏结束事件"""

    def __init__(self, room_id, winner_id=None, scores=None):
        """初始化游戏结束事件"""
        pass


class PlayerJoinEvent(Event):
    """玩家加入事件"""

    def __init__(self, player_id, player_info):
        """初始化玩家加入事件"""
        pass


class PlayerLeaveEvent(Event):
    """玩家离开事件"""

    def __init__(self, player_id, reason=None):
        """初始化玩家离开事件"""
        pass


class EventDispatcher:
    """
    事件分发器：处理事件的注册和分发

    主要功能：
    - 注册事件处理器
    - 分发事件到处理器
    """

    def __init__(self):
        """初始化事件分发器"""
        pass

    def register_handler(self, event_type, handler):
        """注册事件处理器"""
        pass

    def unregister_handler(self, event_type, handler):
        """取消注册事件处理器"""
        pass

    def dispatch(self, event):
        """分发事件到所有注册的处理器"""
        pass


# 单元测试
def test_events():
    """事件系统模块的单元测试"""
    pass


if __name__ == "__main__":
    test_events()

文件名: common/frame_data.py
文件内容
======================================================================
# frame_data.py
"""
帧数据结构模块：定义帧同步系统的数据结构

包含输入帧和状态帧的定义，以及序列化和反序列化功能。
"""

import time
import json
import hashlib
from common.utils import calculate_checksum


class InputCommand:
    """
    输入命令类：表示玩家在一帧中的输入

    主要功能：
    - 存储键盘/鼠标输入状态
    - 序列化和反序列化
    """

    def __init__(self, player_id=None, movement=None, shooting=False, special=None):
        """初始化输入命令"""
        self.player_id = player_id  # 玩家ID
        self.movement = movement  # 移动方向: 'up', 'down', 'left', 'right', 'stop'
        self.shooting = shooting  # 是否射击
        self.special = special  # 特殊技能（预留）
        self.timestamp = time.time()  # 本地时间戳，用于计算延迟

    def to_dict(self):
        """将输入命令转换为字典"""
        return {
            'player_id': self.player_id,
            'movement': self.movement,
            'shooting': self.shooting,
            'special': self.special,
            'timestamp': self.timestamp
        }

    @classmethod
    def from_dict(cls, data):
        """从字典创建输入命令"""
        cmd = cls(
            player_id=data.get('player_id'),
            movement=data.get('movement'),
            shooting=data.get('shooting'),
            special=data.get('special')
        )
        if 'timestamp' in data:
            cmd.timestamp = data['timestamp']
        return cmd

    def serialize(self):
        """序列化为JSON字符串"""
        return json.dumps(self.to_dict())

    @classmethod
    def deserialize(cls, json_str):
        """从JSON字符串反序列化"""
        try:
            data = json.loads(json_str)
            return cls.from_dict(data)
        except json.JSONDecodeError:
            return None

    def __str__(self):
        """字符串表示"""
        return f"InputCommand(player={self.player_id}, move={self.movement}, shoot={self.shooting})"


class InputFrame:
    """
    输入帧类：包含一帧中所有玩家的输入

    主要功能：
    - 存储一帧中的所有输入命令
    - 管理帧ID和时间戳
    - 序列化和反序列化
    """

    def __init__(self, frame_id=0):
        """初始化输入帧"""
        self.frame_id = frame_id  # 帧ID，在游戏进程中唯一
        self.commands = {}  # 玩家ID -> 输入命令的映射
        self.timestamp = time.time()  # 帧创建时间

    def add_command(self, player_id, command):
        """添加玩家的输入命令"""
        if isinstance(command, InputCommand):
            self.commands[player_id] = command
        else:
            # 如果是字典，转换为InputCommand
            self.commands[player_id] = InputCommand.from_dict(command)

    def get_command(self, player_id):
        """获取指定玩家的输入命令"""
        return self.commands.get(player_id)

    def to_dict(self):
        """将输入帧转换为字典"""
        return {
            'frame_id': self.frame_id,
            'timestamp': self.timestamp,
            'commands': {pid: cmd.to_dict() for pid, cmd in self.commands.items()}
        }

    @classmethod
    def from_dict(cls, data):
        """从字典创建输入帧"""
        frame = cls(frame_id=data.get('frame_id', 0))
        frame.timestamp = data.get('timestamp', time.time())

        for pid, cmd_data in data.get('commands', {}).items():
            frame.add_command(pid, InputCommand.from_dict(cmd_data))

        return frame

    def serialize(self):
        """序列化为JSON字符串"""
        return json.dumps(self.to_dict())

    @classmethod
    def deserialize(cls, json_str):
        """从JSON字符串反序列化"""
        try:
            data = json.loads(json_str)
            return cls.from_dict(data)
        except json.JSONDecodeError:
            return None

    def get_checksum(self):
        """计算帧校验和，用于验证一致性"""
        # 只使用输入命令计算校验和，忽略时间戳
        data_for_checksum = {
            'frame_id': self.frame_id,
            'commands': {pid: cmd.to_dict() for pid, cmd in self.commands.items()}
        }
        # 使用JSON字符串的哈希作为校验和
        return hashlib.md5(json.dumps(data_for_checksum, sort_keys=True).encode()).hexdigest()

    def __str__(self):
        """字符串表示"""
        return f"InputFrame(id={self.frame_id}, players={len(self.commands)})"


class StateFrame:
    """
    状态帧类：包含一帧中游戏的完整状态

    主要功能：
    - 存储游戏状态（坦克、子弹等）
    - 管理帧ID和检查点
    - 序列化和反序列化
    """

    def __init__(self, frame_id=0, is_keyframe=False):
        """初始化状态帧"""
        self.frame_id = frame_id  # 帧ID
        self.is_keyframe = is_keyframe  # 是否为关键帧（完整状态）
        self.timestamp = time.time()  # 帧创建时间
        self.game_state = {}  # 游戏状态
        self.checksum = ""  # 状态校验和

    def set_game_state(self, state):
        """设置游戏状态"""
        self.game_state = state
        self._update_checksum()

    def _update_checksum(self):
        """更新状态校验和"""
        # 使用游戏状态计算校验和，忽略时间戳
        data_for_checksum = {
            'frame_id': self.frame_id,
            'game_state': self.game_state
        }
        self.checksum = calculate_checksum(data_for_checksum)

    def to_dict(self):
        """将状态帧转换为字典"""
        return {
            'frame_id': self.frame_id,
            'is_keyframe': self.is_keyframe,
            'timestamp': self.timestamp,
            'game_state': self.game_state,
            'checksum': self.checksum
        }

    @classmethod
    def from_dict(cls, data):
        """从字典创建状态帧"""
        frame = cls(
            frame_id=data.get('frame_id', 0),
            is_keyframe=data.get('is_keyframe', False)
        )
        frame.timestamp = data.get('timestamp', time.time())
        frame.game_state = data.get('game_state', {})
        frame.checksum = data.get('checksum', "")
        return frame

    def serialize(self):
        """序列化为JSON字符串"""
        return json.dumps(self.to_dict())

    @classmethod
    def deserialize(cls, json_str):
        """从JSON字符串反序列化"""
        try:
            data = json.loads(json_str)
            return cls.from_dict(data)
        except json.JSONDecodeError:
            return None

    def verify_checksum(self):
        """验证校验和是否匹配"""
        current_checksum = self.checksum
        self._update_checksum()
        return current_checksum == self.checksum

    def __str__(self):
        """字符串表示"""
        return f"StateFrame(id={self.frame_id}, keyframe={self.is_keyframe})"


class FrameBuffer:
    """
    帧缓冲区：存储和管理输入帧和状态帧

    主要功能：
    - 维护帧历史记录
    - 帧回滚和重放
    - 缓冲区管理
    """

    def __init__(self, max_size=300):
        """初始化帧缓冲区"""
        self.max_size = max_size  # 最大缓冲区大小
        self.input_frames = {}  # 帧ID -> 输入帧
        self.state_frames = {}  # 帧ID -> 状态帧
        self.last_confirmed_frame_id = -1  # 最后确认的帧ID
        self.last_executed_frame_id = -1  # 最后执行的帧ID

    def add_input_frame(self, frame):
        """添加输入帧"""
        if isinstance(frame, dict):
            frame = InputFrame.from_dict(frame)

        self.input_frames[frame.frame_id] = frame
        self._cleanup_buffer()

    def add_state_frame(self, frame):
        """添加状态帧"""
        if isinstance(frame, dict):
            frame = StateFrame.from_dict(frame)

        self.state_frames[frame.frame_id] = frame
        self._cleanup_buffer()

    def get_input_frame(self, frame_id):
        """获取指定帧ID的输入帧"""
        return self.input_frames.get(frame_id)

    def get_state_frame(self, frame_id):
        """获取指定帧ID的状态帧"""
        return self.state_frames.get(frame_id)

    def get_last_keyframe(self):
        """获取最近的关键帧"""
        keyframes = [f for f in self.state_frames.values() if f.is_keyframe]
        if not keyframes:
            return None
        return max(keyframes, key=lambda f: f.frame_id)

    def _cleanup_buffer(self):
        """清理过旧的帧，保持缓冲区大小在限制内"""
        # 如果缓冲区大小超过限制，移除最旧的帧
        while len(self.input_frames) > self.max_size:
            oldest_frame_id = min(self.input_frames.keys())
            del self.input_frames[oldest_frame_id]

        while len(self.state_frames) > self.max_size:
            oldest_frame_id = min(self.state_frames.keys())
            del self.state_frames[oldest_frame_id]

    def set_confirmed_frame(self, frame_id):
        """设置最后确认的帧ID"""
        self.last_confirmed_frame_id = frame_id

    def set_executed_frame(self, frame_id):
        """设置最后执行的帧ID"""
        self.last_executed_frame_id = frame_id

    def get_input_frames_range(self, start_frame_id, end_frame_id):
        """获取指定范围内的输入帧"""
        return {
            fid: frame for fid, frame in self.input_frames.items()
            if start_frame_id <= fid <= end_frame_id
        }

    def __str__(self):
        """字符串表示"""
        return (f"FrameBuffer(inputs={len(self.input_frames)}, "
                f"states={len(self.state_frames)}, "
                f"confirmed={self.last_confirmed_frame_id}, "
                f"executed={self.last_executed_frame_id})")

文件名: common/protocol.py
文件内容
======================================================================
# protocol.py
"""
通信协议模块：定义客户端和服务器之间的通信协议

包含消息类型定义、序列化和反序列化功能。
"""

import json
import time
from common.frame_data import InputFrame, StateFrame, InputCommand

# 消息类型常量
MSG_TYPE_CONNECT = 1  # 连接请求
MSG_TYPE_DISCONNECT = 2  # 断开连接
MSG_TYPE_JOIN_GAME = 3  # 加入游戏
MSG_TYPE_LEAVE_GAME = 4  # 离开游戏
MSG_TYPE_GAME_START = 5  # 游戏开始
MSG_TYPE_GAME_END = 6  # 游戏结束
MSG_TYPE_INPUT = 7  # 输入命令
MSG_TYPE_STATE_UPDATE = 8  # 状态更新
MSG_TYPE_PING = 9  # Ping消息
MSG_TYPE_PONG = 10  # Pong回复
MSG_TYPE_ERROR = 11  # 错误消息
MSG_TYPE_PLAYER_READY = 12  # 玩家准备
MSG_TYPE_ROOM_INFO = 13  # 房间信息


class Message:
    """
    消息类：表示客户端和服务器之间的通信消息

    主要功能：
    - 定义消息结构
    - 序列化和反序列化
    """

    def __init__(self, msg_type, data=None):
        """初始化消息"""
        self.msg_type = msg_type  # 消息类型
        self.data = data or {}  # 消息数据
        self.timestamp = time.time()  # 消息时间戳

    def to_dict(self):
        """将消息转换为字典"""
        return {
            'type': self.msg_type,
            'data': self.data,
            'timestamp': self.timestamp
        }

    @classmethod
    def from_dict(cls, data):
        """从字典创建消息"""
        msg = cls(
            msg_type=data.get('type'),
            data=data.get('data', {})
        )
        msg.timestamp = data.get('timestamp', time.time())
        return msg

    def serialize(self):
        """序列化为JSON字符串"""
        return json.dumps(self.to_dict())

    @classmethod
    def deserialize(cls, json_str):
        """从JSON字符串反序列化"""
        try:
            data = json.loads(json_str)
            return cls.from_dict(data)
        except json.JSONDecodeError:
            return None

    def __str__(self):
        """字符串表示"""
        type_names = {
            MSG_TYPE_CONNECT: "CONNECT",
            MSG_TYPE_DISCONNECT: "DISCONNECT",
            MSG_TYPE_JOIN_GAME: "JOIN_GAME",
            MSG_TYPE_LEAVE_GAME: "LEAVE_GAME",
            MSG_TYPE_GAME_START: "GAME_START",
            MSG_TYPE_GAME_END: "GAME_END",
            MSG_TYPE_INPUT: "INPUT",
            MSG_TYPE_STATE_UPDATE: "STATE_UPDATE",
            MSG_TYPE_PING: "PING",
            MSG_TYPE_PONG: "PONG",
            MSG_TYPE_ERROR: "ERROR",
            MSG_TYPE_PLAYER_READY: "PLAYER_READY",
            MSG_TYPE_ROOM_INFO: "ROOM_INFO"
        }
        type_name = type_names.get(self.msg_type, f"UNKNOWN({self.msg_type})")
        return f"Message({type_name}, data_size={len(str(self.data))})"


# 消息工厂函数
def create_connect_message(client_id, client_info=None):
    """创建连接请求消息"""
    data = {
        'client_id': client_id,
        'client_info': client_info or {}
    }
    return Message(MSG_TYPE_CONNECT, data)


def create_disconnect_message(client_id, reason=None):
    """创建断开连接消息"""
    data = {
        'client_id': client_id,
        'reason': reason
    }
    return Message(MSG_TYPE_DISCONNECT, data)


def create_join_game_message(client_id, room_id=None):
    """创建加入游戏消息"""
    data = {
        'client_id': client_id,
        'room_id': room_id
    }
    return Message(MSG_TYPE_JOIN_GAME, data)


def create_leave_game_message(client_id, room_id):
    """创建离开游戏消息"""
    data = {
        'client_id': client_id,
        'room_id': room_id
    }
    return Message(MSG_TYPE_LEAVE_GAME, data)


def create_game_start_message(room_id, game_info):
    """创建游戏开始消息"""
    data = {
        'room_id': room_id,
        'game_info': game_info
    }
    return Message(MSG_TYPE_GAME_START, data)


def create_game_end_message(room_id, result):
    """创建游戏结束消息"""
    data = {
        'room_id': room_id,
        'result': result
    }
    return Message(MSG_TYPE_GAME_END, data)


def create_input_message(player_id, frame_id, input_command):
    """创建输入命令消息"""
    if isinstance(input_command, InputCommand):
        input_data = input_command.to_dict()
    else:
        input_data = input_command

    data = {
        'player_id': player_id,
        'frame_id': frame_id,
        'input': input_data
    }
    return Message(MSG_TYPE_INPUT, data)


def create_state_update_message(frame_id, state_frame):
    """创建状态更新消息"""
    if isinstance(state_frame, StateFrame):
        state_data = state_frame.to_dict()
    else:
        state_data = state_frame

    data = {
        'frame_id': frame_id,
        'state': state_data
    }
    return Message(MSG_TYPE_STATE_UPDATE, data)


def create_ping_message(client_id):
    """创建Ping消息"""
    data = {
        'client_id': client_id,
        'send_time': time.time()
    }
    return Message(MSG_TYPE_PING, data)


def create_pong_message(ping_data):
    """创建Pong回复消息"""
    data = ping_data.copy()
    data['reply_time'] = time.time()
    return Message(MSG_TYPE_PONG, data)


def create_error_message(error_code, error_message):
    """创建错误消息"""
    data = {
        'code': error_code,
        'message': error_message
    }
    return Message(MSG_TYPE_ERROR, data)


def create_player_ready_message(client_id, room_id, is_ready=True):
    """创建玩家准备消息"""
    data = {
        'client_id': client_id,
        'room_id': room_id,
        'is_ready': is_ready
    }
    return Message(MSG_TYPE_PLAYER_READY, data)


def create_room_info_message(room_id, room_info):
    """创建房间信息消息"""
    data = {
        'room_id': room_id,
        'info': room_info
    }
    return Message(MSG_TYPE_ROOM_INFO, data)


class NetworkLatencyEstimator:
    """
    网络延迟估计器：估计客户端和服务器之间的网络延迟

    主要功能：
    - 记录Ping-Pong往返时间
    - 计算平均延迟和抖动
    """

    def __init__(self, window_size=10):
        """初始化延迟估计器"""
        self.window_size = window_size  # 延迟历史窗口大小
        self.rtt_history = []  # 往返时间历史记录
        self.last_ping_time = 0  # 最后一次Ping的时间

    def send_ping(self):
        """记录发送Ping的时间"""
        self.last_ping_time = time.time()
        return self.last_ping_time

    def receive_pong(self, ping_time=None):
        """
        处理接收到Pong的事件

        Args:
            ping_time: Pong消息中的发送时间，若为None则使用last_ping_time

        Returns:
            当前的往返时间(RTT)
        """
        if ping_time is None:
            ping_time = self.last_ping_time

        if ping_time == 0:
            return 0

        current_time = time.time()
        rtt = (current_time - ping_time) * 1000  # 转换为毫秒

        # 更新RTT历史
        self.rtt_history.append(rtt)
        while len(self.rtt_history) > self.window_size:
            self.rtt_history.pop(0)

        return rtt

    def get_average_rtt(self):
        """获取平均往返时间"""
        if not self.rtt_history:
            return 0
        return sum(self.rtt_history) / len(self.rtt_history)

    def get_rtt_variance(self):
        """获取往返时间的方差（网络抖动）"""
        if not self.rtt_history or len(self.rtt_history) < 2:
            return 0

        avg = self.get_average_rtt()
        variance = sum((x - avg) ** 2 for x in self.rtt_history) / len(self.rtt_history)
        return variance

    def estimate_one_way_delay(self):
        """估计单向延迟（假设上行和下行对称）"""
        return self.get_average_rtt() / 2

    def __str__(self):
        """字符串表示"""
        return (f"LatencyEstimator(avg_rtt={self.get_average_rtt():.2f}ms, "
                f"variance={self.get_rtt_variance():.2f})")

文件名: common/serialization.py
文件内容
======================================================================
# serialization.py
"""
序列化模块：用于游戏数据的序列化和反序列化
提供标准格式转换，确保网络传输的一致性
"""

import json
import pickle
import base64
from common.utils import calculate_checksum


def serialize_inputs(input_data):
    """
    将游戏输入数据序列化为可传输的字符串

    Args:
        input_data: 输入数据字典或对象

    Returns:
        序列化后的字符串
    """
    # 对于简单的输入数据，直接返回原始字典即可
    # 在更复杂的实现中，可能需要更多处理
    return input_data


def deserialize_inputs(serialized_data):
    """
    将序列化的输入数据还原为原始格式

    Args:
        serialized_data: 序列化后的数据

    Returns:
        还原后的输入数据
    """
    # 简单实现，直接返回
    return serialized_data


def serialize_game_state(game_state):
    """
    将完整游戏状态序列化为可传输的字符串

    Args:
        game_state: 游戏状态对象

    Returns:
        序列化后的字符串
    """
    # 使用 pickle 进行完整序列化，并进行 base64 编码
    try:
        pickled = pickle.dumps(game_state)
        return base64.b64encode(pickled).decode('utf-8')
    except Exception as e:
        print(f"Error serializing game state: {e}")
        return None


def deserialize_game_state(serialized_data):
    """
    将序列化的游戏状态还原为原始对象

    Args:
        serialized_data: 序列化后的字符串

    Returns:
        还原后的游戏状态对象
    """
    # 从 base64 解码并使用 pickle 反序列化
    try:
        binary_data = base64.b64decode(serialized_data.encode('utf-8'))
        return pickle.loads(binary_data)
    except Exception as e:
        print(f"Error deserializing game state: {e}")
        return None


def create_input_message(client_id, frame, inputs):
    """
    创建标准格式的输入消息

    Args:
        client_id: 客户端ID
        frame: 帧号
        inputs: 输入数据

    Returns:
        格式化的消息字典
    """
    message = {
        'type': 'input',
        'client_id': client_id,
        'frame': frame,
        'inputs': serialize_inputs(inputs),
        'checksum': calculate_checksum(inputs)
    }
    return message


def create_frame_update_message(frame, inputs, state_checksum=None):
    """
    创建帧更新消息

    Args:
        frame: 当前帧号
        inputs: 所有客户端的输入数据 {client_id: inputs}
        state_checksum: 可选的状态校验和

    Returns:
        格式化的消息字典
    """
    message = {
        'type': 'frame_update',
        'frame': frame,
        'inputs': inputs
    }

    if state_checksum is not None:
        message['state_checksum'] = state_checksum

    return message

文件名: common/utils.py
文件内容
======================================================================
# utils.py
"""
工具函数模块：通用工具函数
"""

import math
import time
import uuid
import logging
import os


def ensure_dir(directory):
    """确保目录存在，如果不存在则创建"""
    if not os.path.exists(directory):
        os.makedirs(directory)


def generate_unique_id():
    """生成唯一标识符"""
    return str(uuid.uuid4())


def distance(pos1, pos2):
    """计算两点间的距离"""
    return math.sqrt((pos2[0] - pos1[0]) ** 2 + (pos2[1] - pos1[1]) ** 2)


def angle_between(pos1, pos2):
    """计算两点间的角度（弧度）"""
    return math.atan2(pos2[1] - pos1[1], pos2[0] - pos1[0])


def angle_to_direction(angle):
    """将角度（弧度）转换为方向向量"""
    return (math.cos(angle), math.sin(angle))


def direction_to_angle(direction):
    """将方向向量转换为角度（弧度）"""
    return math.atan2(direction[1], direction[0])


def vector_from_angle(angle, length=1.0):
    """从角度创建向量"""
    return (math.cos(angle) * length, math.sin(angle) * length)


def vector_length(vector):
    """计算向量长度"""
    return math.sqrt(vector[0] ** 2 + vector[1] ** 2)


def normalize_vector(vector):
    """标准化向量"""
    length = vector_length(vector)
    if length == 0:
        return (0, 0)
    return (vector[0] / length, vector[1] / length)


def clamp(value, min_value, max_value):
    """将值限制在指定范围内"""
    return max(min_value, min(max_value, value))


def is_point_in_rect(point, rect):
    """
    检查点是否在矩形内
    rect 格式为 (x, y, width, height)
    """
    return (rect[0] <= point[0] <= rect[0] + rect[2] and
            rect[1] <= point[1] <= rect[1] + rect[3])


def rect_from_center(center, width, height):
    """从中心点创建矩形"""
    return (center[0] - width / 2, center[1] - height / 2, width, height)


def current_time_ms():
    """获取当前时间的毫秒表示"""
    return int(time.time() * 1000)


def setup_logger(name, log_file, level=logging.INFO):
    """设置日志记录器"""
    handler = logging.FileHandler(log_file)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)

    logger = logging.getLogger(name)
    logger.setLevel(level)
    logger.addHandler(handler)

    return logger


def log_message(message, level='INFO', logger=None):
    """记录日志消息"""
    if logger:
        if level == 'DEBUG':
            logger.debug(message)
        elif level == 'INFO':
            logger.info(message)
        elif level == 'WARNING':
            logger.warning(message)
        elif level == 'ERROR':
            logger.error(message)
        elif level == 'CRITICAL':
            logger.critical(message)
    else:
        print(f"[{level}] {message}")


def degrees_to_radians(degrees):
    """将角度转换为弧度"""
    return degrees * math.pi / 180


def radians_to_degrees(radians):
    """将弧度转换为角度"""
    return radians * 180 / math.pi


def collide_rect(rect1, rect2):
    """
    检测两个矩形是否碰撞
    rect 格式为 (x, y, width, height)
    """
    return (rect1[0] < rect2[0] + rect2[2] and
            rect1[0] + rect1[2] > rect2[0] and
            rect1[1] < rect2[1] + rect2[3] and
            rect1[1] + rect1[3] > rect2[1])


def calculate_checksum(data):
    """计算数据的简单校验和"""
    if isinstance(data, dict):
        # 对字典进行排序以确保一致性
        return hash(tuple(sorted((k, calculate_checksum(v)) for k, v in data.items())))
    elif isinstance(data, list) or isinstance(data, tuple):
        return hash(tuple(calculate_checksum(item) for item in data))
    else:
        return hash(data)


# 单元测试
def test_utils():
    """工具函数模块的单元测试"""
    # 测试距离计算
    assert distance((0, 0), (3, 4)) == 5

    # 测试向量操作
    angle = math.pi / 4  # 45度
    vec = vector_from_angle(angle, 1.0)
    assert abs(vec[0] - 0.7071) < 0.0001
    assert abs(vec[1] - 0.7071) < 0.0001

    # 测试clamp函数
    assert clamp(5, 0, 10) == 5
    assert clamp(-1, 0, 10) == 0
    assert clamp(11, 0, 10) == 10

    # 测试矩形函数
    rect = rect_from_center((50, 50), 20, 20)
    assert rect == (40, 40, 20, 20)
    assert is_point_in_rect((45, 45), rect)
    assert not is_point_in_rect((30, 30), rect)

    print("All utils tests passed!")


if __name__ == "__main__":
    test_utils()

文件名: server/ai/pathfinding.py
文件内容
======================================================================
# pathfinding.py
"""
寻路算法模块：实现AI坦克的寻路功能
"""


class PathFinder:
    """
    寻路器：实现A*寻路算法

    主要功能：
    - 查找从起点到终点的最短路径
    - 避开障碍物
    - 处理地图网格
    """

    def __init__(self, map_grid):
        """初始化寻路器"""
        pass

    def find_path(self, start, end):
        """查找从起点到终点的路径"""
        pass

    def get_neighbors(self, position):
        """获取相邻的可通行位置"""
        pass

    def calculate_cost(self, start, end):
        """计算两点间的路径成本"""
        pass

    def is_valid_position(self, position):
        """检查位置是否有效且可通行"""
        pass

    def simplify_path(self, path):
        """简化路径，减少冗余点"""
        pass


class MapGrid:
    """
    地图网格：表示游戏地图的网格表示

    主要功能：
    - 将实际地图转换为网格
    - 标记障碍物
    - 提供网格查询
    """

    def __init__(self, map_data, cell_size=10):
        """初始化地图网格"""
        pass

    def is_obstacle(self, x, y):
        """检查网格位置是否是障碍物"""
        pass

    def world_to_grid(self, world_x, world_y):
        """将世界坐标转换为网格坐标"""
        pass

    def grid_to_world(self, grid_x, grid_y):
        """将网格坐标转换为世界坐标"""
        pass

    def update_from_map(self, map_data):
        """根据最新地图数据更新网格"""
        pass

    def get_grid_size(self):
        """获取网格大小"""
        pass

    def serialize(self):
        """序列化网格数据"""
        pass

    @classmethod
    def deserialize(cls, data):
        """从序列化数据创建网格"""
        pass


# 单元测试
def test_pathfinding():
    """寻路算法模块的单元测试"""
    pass


if __name__ == "__main__":
    test_pathfinding()

文件名: server/ai/tank_ai.py
文件内容
======================================================================
# tank_ai.py
"""
坦克AI模块：实现AI控制的坦克行为
"""


class TankAI:
    """
    坦克AI：控制AI坦克的行为

    主要功能：
    - 移动决策
    - 射击决策
    - 躲避障碍物
    - 追踪敌人
    """

    def __init__(self, tank_id, difficulty='medium'):
        """初始化坦克AI"""
        pass

    def update(self, game_state):
        """更新AI决策"""
        pass

    def decide_movement(self, game_state):
        """决定移动方向"""
        pass

    def decide_shooting(self, game_state):
        """决定是否射击"""
        pass

    def find_nearest_enemy(self, game_state):
        """寻找最近的敌人"""
        pass

    def avoid_obstacles(self, game_state):
        """避开障碍物"""
        pass

    def avoid_bullets(self, game_state):
        """避开子弹"""
        pass

    def get_input(self, game_state, frame_number):
        """获取AI的输入决策"""
        pass

    def set_difficulty(self, difficulty):
        """设置AI难度"""
        pass


class AIManager:
    """
    AI管理器：管理所有AI坦克

    主要功能：
    - 创建和删除AI坦克
    - 更新所有AI决策
    - 调整AI难度
    - 生成AI输入
    """

    def __init__(self):
        """初始化AI管理器"""
        pass

    def create_ai(self, tank_id, difficulty='medium'):
        """创建新的AI控制器"""
        pass

    def remove_ai(self, tank_id):
        """移除AI控制器"""
        pass

    def update_all(self, game_state):
        """更新所有AI决策"""
        pass

    def set_difficulty(self, difficulty):
        """设置所有AI的难度"""
        pass

    def get_ai_inputs(self, game_state, frame_number):
        """获取所有AI的输入决策"""
        pass

    def has_ai(self, tank_id):
        """检查指定坦克是否由AI控制"""
        pass


# 单元测试
def test_tank_ai():
    """坦克AI模块的单元测试"""
    pass


if __name__ == "__main__":
    test_tank_ai()

文件名: server/frame_sync/frame_manager.py
文件内容
======================================================================
# server/frame_sync/frame_manager.py
import time
from collections import defaultdict
from common.constants import FRAME_RATE


class FrameManager:
    def __init__(self, turn_size=5):
        self.current_frame = 0
        self.turn_size = turn_size  # 每个turn的帧数
        self.clients = {}  # client_id -> client_session
        self.input_buffer = defaultdict(dict)  # frame -> {client_id -> inputs}
        self.ready_clients = set()  # 准备好的客户端
        self.game_started = False
        self.game_start_time = 0

    def add_client(self, client_id, client_session):
        """添加客户端连接"""
        self.clients[client_id] = client_session

    def remove_client(self, client_id):
        """移除客户端连接"""
        if client_id in self.clients:
            del self.clients[client_id]
        if client_id in self.ready_clients:
            self.ready_clients.remove(client_id)

    def receive_input(self, client_id, frame, inputs):
        """接收客户端输入"""
        self.input_buffer[frame][client_id] = inputs

    def mark_client_ready(self, client_id):
        """标记客户端已准备好"""
        self.ready_clients.add(client_id)
        print(
            f"[FrameManager] Client {client_id} marked as ready. Ready clients: {len(self.ready_clients)}/{len(self.clients)}")
        return len(self.ready_clients) == len(self.clients)

    def start_game(self, delay_ms=500):
        """开始游戏，设置开始时间"""
        self.game_started = True
        self.game_start_time = int(time.time() * 1000) + delay_ms
        print(f"[FrameManager] Game starting at {self.game_start_time} (current time + {delay_ms}ms)")
        return self.game_start_time

    def prepare_input_broadcast(self):
        """准备广播给所有客户端的输入数据"""
        # 计算本次广播包含的帧范围
        start_frame = self.current_frame - self.turn_size + 1
        end_frame = self.current_frame

        # 收集这些帧的所有输入
        turn_inputs = {}
        for frame in range(start_frame, end_frame + 1):
            if frame in self.input_buffer and self.input_buffer[frame]:  # 确保有输入
                turn_inputs[str(frame)] = self.input_buffer[frame]

        # 打印调试信息
        input_count = sum(len(inputs) for inputs in turn_inputs.values())
        print(f"[Server] Prepared broadcast for frames {start_frame}-{end_frame} with {input_count} total inputs")

        # 清理旧的输入缓存（可选，取决于是否需要保存用于回放）
        for frame in list(self.input_buffer.keys()):
            if frame <= self.current_frame - self.turn_size * 2:
                del self.input_buffer[frame]

        # 返回需要广播的数据
        return {
            'type': 'input_frame',
            'current_frame': self.current_frame,
            'inputs': turn_inputs
        }

    def reset(self):
        """重置帧管理器状态"""
        self.current_frame = 0
        self.input_buffer = defaultdict(dict)
        self.ready_clients = set()
        self.game_started = False
        self.game_start_time = 0
        print("[FrameManager] Reset complete")

文件名: server/frame_sync/validator.py
文件内容
======================================================================
# validator.py
"""
验证模块：验证游戏状态一致性
"""


class Validator:
    """
    验证器：验证游戏状态一致性

    主要功能：
    - 收集客户端校验和
    - 检测状态不一致
    - 触发状态恢复
    """

    def __init__(self):
        """初始化验证器"""
        pass

    def add_checksum(self, player_id, checksum, frame_number):
        """添加玩家状态校验和"""
        pass

    def verify_checksums(self, frame_number):
        """验证指定帧的所有玩家校验和"""
        pass

    def get_reference_checksum(self, frame_number):
        """获取参考校验和（多数玩家的校验和）"""
        pass

    def get_mismatched_clients(self, frame_number):
        """获取校验和不匹配的客户端列表"""
        pass

    def should_trigger_resync(self, frame_number):
        """检查是否应触发重新同步"""
        pass

    def clear_old_checksums(self, before_frame):
        """清除旧帧的校验和数据"""
        pass


# 单元测试
def test_validator():
    """验证器的单元测试"""
    pass


if __name__ == "__main__":
    test_validator()

文件名: server/network/protocol.py
文件内容
======================================================================
# protocol.py
"""
通信协议模块：定义服务器和客户端之间的通信协议
"""


class Protocol:
    """
    协议类：封装网络通信协议

    主要功能：
    - 定义消息类型
    - 序列化和反序列化消息
    - 处理消息编码和解码
    """

    # 消息类型常量
    CONNECTION_REQUEST = 1
    CONNECTION_ACCEPTED = 2
    DISCONNECTION = 3
    GAME_START = 4
    GAME_END = 5
    PLAYER_INPUT = 6
    FRAME_DATA = 7
    STATE_CHECKSUM = 8
    STATE_SYNC_REQUEST = 9
    STATE_SYNC_RESPONSE = 10

    @staticmethod
    def encode_message(msg_type, data):
        """将消息编码为可传输的格式"""
        pass

    @staticmethod
    def decode_message(message):
        """将接收到的消息解码"""
        pass

    @staticmethod
    def create_connection_accepted(client_id, server_info):
        """创建连接接受消息"""
        pass

    @staticmethod
    def create_frame_data(frame_number, inputs):
        """创建帧数据消息"""
        pass

    @staticmethod
    def create_game_start(initial_state, map_seed, start_frame):
        """创建游戏开始消息"""
        pass

    @staticmethod
    def create_game_end(winner_id, stats):
        """创建游戏结束消息"""
        pass

    @staticmethod
    def create_state_sync_response(full_state, frame_number):
        """创建状态同步响应消息"""
        pass


# 单元测试
def test_protocol():
    """协议模块的单元测试"""
    pass


if __name__ == "__main__":
    test_protocol()

文件名: server/network/server.py
文件内容
======================================================================
# server/network/server.py
"""
网络服务器模块：处理网络通信
"""

import socket
import threading
import json
import time
import struct
from queue import Queue

from common.constants import SERVER_IP, SERVER_PORT, NET_DEBUG


class NetworkServer:
    """
    网络服务器：处理客户端连接和通信

    主要功能：
    - 接受客户端连接
    - 发送和接收消息
    - 管理客户端列表
    """

    def __init__(self, host=SERVER_IP, port=SERVER_PORT):
        """初始化网络服务器"""
        self.host = host
        self.port = port
        self.socket = None
        self.running = False

        # 客户端连接
        self.clients = {}  # client_id -> client_socket
        self.client_addresses = {}  # client_id -> address

        # 线程和队列
        self.accept_thread = None
        self.message_queue = Queue()

        # 消息处理回调
        self.message_handlers = {}

        # 调试标志
        self.debug = NET_DEBUG

    def start(self):
        """启动服务器"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind((self.host, self.port))
            self.socket.listen(10)

            self.running = True

            # 启动接受客户端线程
            self.accept_thread = threading.Thread(target=self._accept_clients)
            self.accept_thread.daemon = True
            self.accept_thread.start()

            if self.debug:
                print(f"Server started on {self.host}:{self.port}")

            return True

        except Exception as e:
            if self.debug:
                print(f"Error starting server: {e}")
            return False

    def stop(self):
        """停止服务器"""
        self.running = False

        # 关闭所有客户端连接
        for client_id, client_socket in list(self.clients.items()):
            try:
                client_socket.close()
            except:
                pass

        # 关闭服务器套接字
        if self.socket:
            try:
                self.socket.close()
            except:
                pass

        if self.debug:
            print("Server stopped")

    def register_handler(self, message_type, handler_function):
        """
        注册消息处理函数

        Args:
            message_type: 消息类型
            handler_function: 处理函数，接收(client_id, message)作为参数
        """
        self.message_handlers[message_type] = handler_function

    def send_message(self, client_id, message):
        """
        发送消息给指定客户端

        Args:
            client_id: 客户端ID
            message: 要发送的消息（字典）

        Returns:
            布尔值，表示是否发送成功
        """
        if client_id not in self.clients:
            return False

        try:
            # 序列化消息
            msg_json = json.dumps(message)
            msg_bytes = msg_json.encode('utf-8')

            # 添加长度前缀
            msg_len = len(msg_bytes)
            prefix = struct.pack('!I', msg_len)

            # 发送消息
            self.clients[client_id].sendall(prefix + msg_bytes)

            if self.debug and message.get('type') != 'input_frame' and message.get('type') != 'game_state':
                print(f"Sent to {client_id}: {message}")

            return True
        except Exception as e:
            if self.debug:
                print(f"Error sending message to {client_id}: {e}")

            # 客户端可能已断开连接，移除
            self._remove_client(client_id)

            return False

    def broadcast_message(self, message, exclude_client_id=None):
        """
        广播消息给所有客户端

        Args:
            message: 要广播的消息（字典）
            exclude_client_id: 要排除的客户端ID
        """
        for client_id in list(self.clients.keys()):
            if exclude_client_id and client_id == exclude_client_id:
                continue
            self.send_message(client_id, message)

    def process_messages(self):
        """
        处理消息队列中的所有消息

        Returns:
            处理的消息数量
        """
        processed = 0
        while not self.message_queue.empty():
            try:
                client_id, message = self.message_queue.get_nowait()
                message_type = message.get('type')

                # 调用对应的处理函数
                if message_type in self.message_handlers:
                    self.message_handlers[message_type](client_id, message)

                self.message_queue.task_done()
                processed += 1

            except Exception as e:
                if self.debug:
                    print(f"Error processing message: {e}")
                break

        return processed

    def get_client_count(self):
        """
        获取当前连接的客户端数量

        Returns:
            客户端数量
        """
        return len(self.clients)

    def get_client_list(self):
        """
        获取客户端列表

        Returns:
            客户端ID列表
        """
        return list(self.clients.keys())

    def _accept_clients(self):
        """接受客户端连接的线程函数"""
        while self.running:
            try:
                client_socket, address = self.socket.accept()
                client_thread = threading.Thread(
                    target=self._handle_client,
                    args=(client_socket, address)
                )
                client_thread.daemon = True
                client_thread.start()
            except Exception as e:
                if self.running:  # 只在仍然运行时打印错误
                    if self.debug:
                        print(f"Error accepting client: {e}")
                break

    def _handle_client(self, client_socket, address):
        """
        处理单个客户端的连接

        Args:
            client_socket: 客户端套接字
            address: 客户端地址
        """
        client_id = None
        buffer = b''

        if self.debug:
            print(f"New client connected: {address}")

        try:
            while self.running:
                # 读取消息头（4字节，表示消息长度）
                while len(buffer) < 4:
                    data = client_socket.recv(4096)
                    if not data:
                        raise Exception("Connection closed by client")
                    buffer += data

                # 获取消息长度并读取完整消息
                msg_len = struct.unpack('!I', buffer[:4])[0]
                buffer = buffer[4:]

                while len(buffer) < msg_len:
                    data = client_socket.recv(4096)
                    if not data:
                        raise Exception("Connection closed by client")
                    buffer += data

                # 提取完整消息并处理
                msg_data = buffer[:msg_len]
                buffer = buffer[msg_len:]

                # 解析JSON消息
                try:
                    message = json.loads(msg_data.decode('utf-8'))

                    # 获取客户端ID（如果是连接消息或已知客户端）
                    if message.get('type') == 'connect':
                        client_id = message.get('client_id')
                        self.clients[client_id] = client_socket
                        self.client_addresses[client_id] = address

                        if self.debug:
                            print(f"Client identified: {client_id} from {address}")
                    elif 'client_id' in message:
                        client_id = message.get('client_id')

                    # 将消息添加到队列
                    if client_id:
                        self.message_queue.put((client_id, message))

                    if self.debug and message.get('type') != 'input_frame' and message.get('type') != 'game_state':
                        print(f"Received from {client_id}: {message}")

                except json.JSONDecodeError:
                    if self.debug:
                        print(f"Error decoding message from {address}")

        except Exception as e:
            if self.running:  # 只在仍然运行时打印错误
                if self.debug:
                    print(f"Error handling client {client_id}: {e}")
        finally:
            # 关闭连接并清理
            try:
                client_socket.close()
            except:
                pass

            if client_id:
                self._remove_client(client_id)

    def _remove_client(self, client_id):
        """
        移除客户端

        Args:
            client_id: 要移除的客户端ID
        """
        if client_id in self.clients:
            del self.clients[client_id]

        if client_id in self.client_addresses:
            address = self.client_addresses[client_id]
            del self.client_addresses[client_id]

            if self.debug:
                print(f"Client disconnected: {client_id} from {address}")

文件名: server/main.py
文件内容
======================================================================
# server/main.py
import asyncio
import websockets
import json
import time
import uuid
from collections import defaultdict
from server.frame_sync.frame_manager import FrameManager
from common.constants import FRAME_RATE


class GameServer:
    def __init__(self, port=8766, required_players=2):
        self.port = port
        self.clients = {}  # websocket -> client_id
        self.client_details = {}  # client_id -> details
        self.frame_manager = FrameManager()
        self.connection_phase = True
        self.server = None
        self.required_players = required_players  # 需要的玩家数量
        print(f"[Server] Initialized with port {port}, requiring {required_players} players")

    async def handle_client(self, websocket, path):
        """处理客户端连接"""
        # 如果游戏已经开始，拒绝新连接
        if self.frame_manager.game_started:
            print(f"[Server] Rejecting new connection - game already in progress")
            await websocket.close(1000, "Game already in progress")
            return

        client_id = str(uuid.uuid4())
        self.clients[websocket] = client_id
        self.client_details[client_id] = {
            'connected_at': int(time.time()),
            'ready': False
        }

        print(f"[Server] New client connected with ID: {client_id}")
        print(f"[Server] Connected players: {len(self.clients)}/{self.required_players}")

        try:
            # 发送欢迎消息
            welcome_message = {
                'type': 'welcome',
                'client_id': client_id
            }
            await websocket.send(json.dumps(welcome_message))

            # 加入帧管理器
            self.frame_manager.add_client(client_id, websocket)

            # 检查是否已达到所需玩家数量
            if self.connection_phase and len(self.clients) >= self.required_players:
                print(f"[Server] Required number of players ({self.required_players}) reached!")
                # 发送游戏准备消息
                ready_message = {
                    'type': 'game_ready',
                    'players': len(self.clients)
                }
                print(f"[Server] Broadcasting game_ready message to {len(self.clients)} players")
                await self.broadcast(ready_message)

            # 持续接收消息
            async for message in websocket:
                try:
                    data = json.loads(message)
                    await self.process_message(websocket, client_id, data)
                except json.JSONDecodeError:
                    print(f"[Server] Invalid JSON from client {client_id}")
        except websockets.exceptions.ConnectionClosed as e:
            print(f"[Server] Client {client_id} disconnected: {e.code} {e.reason}")
        except Exception as e:
            print(f"[Server] Error handling client {client_id}: {e}")
        finally:
            # 客户端断开连接，清理资源
            if websocket in self.clients:
                del self.clients[websocket]
            if client_id in self.client_details:
                del self.client_details[client_id]
            self.frame_manager.remove_client(client_id)

            print(
                f"[Server] Client {client_id} removed. Remaining players: {len(self.clients)}/{self.required_players}")

            # 如果游戏已经开始，但玩家数量不足，重置游戏
            if self.frame_manager.game_started and len(self.clients) < self.required_players:
                print(f"[Server] Not enough players to continue. Resetting game.")
                self.reset_game()

    def reset_game(self):
        """重置游戏状态"""
        self.frame_manager = FrameManager()  # 创建新的帧管理器
        self.connection_phase = True
        print(f"[Server] Game reset. Waiting for {self.required_players} players to connect.")

    async def process_message(self, websocket, client_id, data):
        """处理客户端消息"""
        msg_type = data.get('type')
        print(f"[Server] Received {msg_type} message from client {client_id}")

        if msg_type == 'connect_request':
            # 连接请求
            print(f"[Server] Client {client_id} sent connect_request")

        elif msg_type == 'client_ready':
            # 客户端准备就绪
            print(f"[Server] Client {client_id} is ready")

            # 更新客户端状态
            if client_id in self.client_details:
                self.client_details[client_id]['ready'] = True

            # 标记客户端准备就绪
            all_ready = self.frame_manager.mark_client_ready(client_id)

            # 检查是否所有客户端都已准备就绪
            ready_count = sum(1 for details in self.client_details.values() if details['ready'])
            total_count = len(self.clients)
            print(f"[Server] Ready clients: {ready_count}/{total_count}")

            if all_ready:
                # 所有客户端都准备好了，开始游戏
                # 设置游戏开始时间为当前时间+500ms
                start_delay_ms = 500
                game_start_time = self.frame_manager.start_game(start_delay_ms)
                start_message = {
                    'type': 'game_start',
                    'start_time': game_start_time,
                    'players': len(self.clients)
                }
                print(f"[Server] All clients ready, starting game at {game_start_time} (in {start_delay_ms}ms)")
                await self.broadcast(start_message)

        elif msg_type == 'input':
            # 处理客户端输入
            frame = data.get('frame')
            inputs = data.get('inputs')
            print(f"[Server] Input from {client_id} for frame {frame}")
            self.frame_manager.receive_input(client_id, frame, inputs)

    async def broadcast(self, message):
        """向所有客户端广播消息"""
        if not self.clients:
            print("[Server] No clients to broadcast to")
            return

        message_json = json.dumps(message)
        print(f"[Server] Broadcasting message type: {message.get('type')} to {len(self.clients)} clients")

        # 创建所有发送任务
        send_tasks = []
        for websocket in self.clients:
            try:
                await websocket.send(message_json)
                client_id = self.clients.get(websocket, "unknown")
                print(f"[Server] Sent message to client {client_id}")
            except Exception as e:
                client_id = self.clients.get(websocket, "unknown")
                print(f"[Server] Error sending to client {client_id}: {e}")

    async def start_server(self):
        """启动游戏服务器"""
        # 创建WebSocket服务器
        self.server = await websockets.serve(
            self.handle_client,
            "localhost",  # 使用localhost以便于测试
            self.port
        )

        print(f"[Server] Game server started on localhost:{self.port}")
        print(f"[Server] Waiting for {self.required_players} players to connect...")

        # 启动游戏循环
        await self.game_loop()

    async def game_loop(self):
        """游戏主循环"""
        debug_interval = 5  # 每5秒打印一次调试信息
        last_debug_time = 0

        while True:
            current_time = int(time.time())

            # 定期打印调试信息
            if current_time - last_debug_time >= debug_interval:
                self.print_server_state()
                last_debug_time = current_time

            # 游戏已经开始，处理帧更新
            if self.frame_manager.game_started:
                current_time_ms = int(time.time() * 1000)
                elapsed_time = current_time_ms - self.frame_manager.game_start_time

                # 只有在游戏开始时间已过后才进行帧更新
                if elapsed_time >= 0:
                    frames_elapsed = elapsed_time * FRAME_RATE // 1000

                    # 仅当需要更新时广播帧更新
                    if frames_elapsed > self.frame_manager.current_frame:
                        # 更新到当前应该的帧
                        self.frame_manager.current_frame = frames_elapsed

                        # 每turn_size帧广播一次输入
                        if self.frame_manager.current_frame % self.frame_manager.turn_size == 0:
                            input_message = self.frame_manager.prepare_input_broadcast()
                            print(f"[Server] Broadcasting inputs for frame {self.frame_manager.current_frame}")
                            await self.broadcast(input_message)

            # 短暂等待避免CPU占用过高
            await asyncio.sleep(0.01)

    def print_server_state(self):
        """打印服务器当前状态（用于调试）"""
        print("\n=== SERVER STATE ===")
        print(f"Connected clients: {len(self.clients)}/{self.required_players}")
        print(f"Connection phase: {self.connection_phase}")
        print(f"Game started: {self.frame_manager.game_started}")

        if self.client_details:
            print("Client details:")
            for client_id, details in self.client_details.items():
                print(f"  - {client_id[:8]}...: Ready: {details['ready']}")

        if self.frame_manager.game_started:
            print(f"Current frame: {self.frame_manager.current_frame}")
            print(f"Ready clients: {len(self.frame_manager.ready_clients)}/{len(self.clients)}")
            print(f"Game start time: {self.frame_manager.game_start_time}")
        print("===================\n")

    async def stop_server(self):
        """停止服务器"""
        if self.server:
            self.server.close()
            await self.server.wait_closed()
            print("[Server] Server stopped")


# 主函数
async def main():
    # 可以通过命令行参数来指定所需的玩家数量
    import sys
    required_players = 2  # 默认为2
    if len(sys.argv) > 1:
        try:
            required_players = int(sys.argv[1])
            print(f"[Server] Setting required players to: {required_players}")
        except ValueError:
            print(f"[Server] Invalid player count: {sys.argv[1]}, using default: {required_players}")

    server = GameServer(required_players=required_players)
    try:
        await server.start_server()
    except KeyboardInterrupt:
        print("[Server] Interrupted, shutting down...")
        await server.stop_server()
    except Exception as e:
        print(f"[Server] Error: {e}")
        await server.stop_server()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("[Server] Server shutting down")

文件名: server/room.py
文件内容
======================================================================
# server/room.py
"""
房间管理模块：管理游戏房间和客户端
"""

import time
from common.constants import FRAME_DEBUG


class Room:
    """
    游戏房间：管理一组客户端和一个游戏会话

    主要功能：
    - 管理客户端加入和离开
    - 跟踪房间状态
    - 关联游戏会话
    """

    def __init__(self, room_id, name="Game Room", max_clients=4):
        """
        初始化游戏房间

        Args:
            room_id: 房间ID
            name: 房间名称
            max_clients: 最大客户端数量
        """
        self.id = room_id
        self.name = name
        self.max_clients = max_clients
        self.clients = []
        self.status = "waiting"  # waiting, starting, running, ended
        self.session = None
        self.create_time = time.time()

        # 房间配置
        self.settings = {
            "map": "random",
            "mode": "deathmatch",
            "time_limit": 300,  # 秒
            "seed": int(time.time())
        }

        # 调试标志
        self.debug = FRAME_DEBUG

    def add_client(self, client_id):
        """
        将客户端添加到房间

        Args:
            client_id: 客户端ID

        Returns:
            布尔值，表示添加是否成功
        """
        # 检查是否已经在房间中
        if client_id in self.clients:
            if self.debug:
                print(f"Client {client_id} already in room {self.id}")
            return False

        # 检查房间是否已满
        if len(self.clients) >= self.max_clients:
            if self.debug:
                print(f"Room {self.id} is full, cannot add client {client_id}")
            return False

        # 检查房间是否已经开始游戏
        if self.status not in ["waiting", "starting"]:
            if self.debug:
                print(f"Room {self.id} has already started, cannot add client {client_id}")
            return False

        # 添加客户端
        self.clients.append(client_id)

        # 通知会话有新客户端加入
        if self.session:
            self.session.client_joined(client_id)

        if self.debug:
            print(f"Client {client_id} added to room {self.id}")

        return True

    def remove_client(self, client_id):
        """
        从房间移除客户端

        Args:
            client_id: 客户端ID

        Returns:
            布尔值，表示移除是否成功
        """
        if client_id not in self.clients:
            return False

        # 移除客户端
        self.clients.remove(client_id)

        # 通知会话有客户端离开
        if self.session:
            self.session.client_left(client_id)

        if self.debug:
            print(f"Client {client_id} removed from room {self.id}")

        # 如果房间空了，重置状态
        if not self.clients:
            self.reset()

        return True

    def set_session(self, session):
        """
        设置关联的游戏会话

        Args:
            session: 游戏会话
        """
        self.session = session
        if session:
            session.set_room(self)
            if self.debug:
                print(f"Session {session.id} assigned to room {self.id}")

    def get_session(self):
        """
        获取关联的游戏会话

        Returns:
            游戏会话
        """
        return self.session

    def get_settings(self):
        """
        获取房间设置

        Returns:
            房间设置字典
        """
        return self.settings

    def update_settings(self, settings):
        """
        更新房间设置

        Args:
            settings: 新的设置字典
        """
        self.settings.update(settings)
        if self.debug:
            print(f"Room {self.id} settings updated: {settings}")

    def start_game(self):
        """
        开始游戏

        Returns:
            布尔值，表示是否成功开始游戏
        """
        if not self.clients:
            if self.debug:
                print(f"Cannot start game in empty room {self.id}")
            return False

        if not self.session:
            if self.debug:
                print(f"Cannot start game in room {self.id}, no session assigned")
            return False

        if self.status != "waiting":
            if self.debug:
                print(f"Room {self.id} already started or ended")
            return False

        # 更新状态为开始中
        self.status = "starting"

        # 启动会话
        success = self.session.start_game()

        if success:
            self.status = "running"
            if self.debug:
                print(f"Game started in room {self.id}")
        else:
            self.status = "waiting"
            if self.debug:
                print(f"Failed to start game in room {self.id}")

        return success

    def end_game(self, winner=None):
        """
        结束游戏

        Args:
            winner: 胜利者ID或团队
        """
        if self.status != "running":
            return

        self.status = "ended"

        if self.session:
            self.session.end_game(winner)

        if self.debug:
            print(f"Game ended in room {self.id}, winner: {winner}")

    def reset(self):
        """重置房间状态"""
        self.status = "waiting"

        # 更新随机种子
        self.settings["seed"] = int(time.time())

        if self.debug:
            print(f"Room {self.id} reset to waiting state")

    def get_client_count(self):
        """
        获取客户端数量

        Returns:
            客户端数量
        """
        return len(self.clients)

    def is_full(self):
        """
        检查房间是否已满

        Returns:
            布尔值，表示房间是否已满
        """
        return len(self.clients) >= self.max_clients

    def is_empty(self):
        """
        检查房间是否为空

        Returns:
            布尔值，表示房间是否为空
        """
        return len(self.clients) == 0

    def serialize(self):
        """
        序列化房间信息

        Returns:
            房间信息字典
        """
        return {
            "id": self.id,
            "name": self.name,
            "clients": self.clients,
            "client_count": len(self.clients),
            "max_clients": self.max_clients,
            "status": self.status,
            "settings": self.settings,
            "create_time": self.create_time
        }

文件名: server/session.py
文件内容
======================================================================
# server/session.py
"""
会话管理模块：管理游戏会话和状态
"""

import time
import random
import hashlib
import json
from common.constants import FRAME_DEBUG


class GameSession:
    """
    游戏会话：管理游戏状态和逻辑

    主要功能：
    - 维护游戏状态
    - 处理游戏逻辑
    - 提供状态同步支持
    """

    def __init__(self, session_id, network_server=None):
        """
        初始化游戏会话

        Args:
            session_id: 会话ID
            network_server: 网络服务器实例
        """
        self.id = session_id
        self.network_server = network_server
        self.room = None
        self.players = {}  # player_id -> player_data
        self.game_state = {
            "tanks": [],
            "bullets": [],
            "game_over": False,
            "winner": None,
            "timestamp": time.time()
        }
        self.status = "waiting"  # waiting, running, ended
        self.start_time = 0
        self.end_time = 0

        # 调试标志
        self.debug = FRAME_DEBUG

    def set_room(self, room):
        """
        设置关联的房间

        Args:
            room: 房间实例
        """
        self.room = room

    def client_joined(self, client_id):
        """
        处理客户端加入

        Args:
            client_id: 客户端ID
        """
        # 如果游戏已经开始，不允许加入
        if self.status == "running":
            if self.debug:
                print(f"Session {self.id}: Cannot add player {client_id}, game already running")
            return

        # 如果不是新客户端，忽略
        if client_id in self.players:
            return

        # 添加新玩家
        player_index = len(self.players)
        colors = ['blue', 'red', 'green', 'yellow']

        self.players[client_id] = {
            "id": client_id,
            "index": player_index,
            "color": colors[player_index % len(colors)],
            "ready": False,
            "score": 0,
            "kills": 0,
            "deaths": 0
        }

        if self.debug:
            print(f"Session {self.id}: Added player {client_id} with index {player_index}")

    def client_left(self, client_id):
        """
        处理客户端离开

        Args:
            client_id: 客户端ID
        """
        # 如果不是已知客户端，忽略
        if client_id not in self.players:
            return

        # 移除玩家
        del self.players[client_id]

        if self.debug:
            print(f"Session {self.id}: Removed player {client_id}")

        # 如果游戏正在运行，检查是否应该结束游戏
        if self.status == "running" and not self.players:
            self.end_game()

    def start_game(self):
        """
        开始游戏

        Returns:
            布尔值，表示是否成功开始游戏
        """
        if not self.players:
            if self.debug:
                print(f"Session {self.id}: Cannot start game with no players")
            return False

        if not self.room:
            if self.debug:
                print(f"Session {self.id}: Cannot start game, no room assigned")
            return False

        if self.status == "running":
            if self.debug:
                print(f"Session {self.id}: Game already running")
            return False

        # 获取房间设置
        settings = self.room.get_settings()
        seed = settings.get("seed", int(time.time()))
        map_name = settings.get("map", "random")

        # 更新状态
        self.status = "running"
        self.start_time = time.time()

        # 创建玩家列表
        players_list = []
        for client_id, player_data in self.players.items():
            players_list.append(player_data)

        # 给所有客户端发送游戏开始消息
        if self.network_server:
            for client_id in self.players:
                self.network_server.send_message(client_id, {
                    'type': 'game_start',
                    'game_id': self.id,
                    'seed': seed,
                    'map_name': map_name,
                    'player_id': client_id,
                    'player_index': self.players[client_id]['index'],
                    'players': players_list
                })

        if self.debug:
            print(f"Session {self.id}: Game started with seed {seed}")

        return True

    def end_game(self, winner=None):
        """
        结束游戏

        Args:
            winner: 胜利者ID或团队
        """
        if self.status != "running":
            return

        self.status = "ended"
        self.end_time = time.time()

        # 更新游戏状态
        self.game_state["game_over"] = True
        self.game_state["winner"] = winner

        # 发送游戏结束消息
        if self.network_server:
            for client_id in self.players:
                self.network_server.send_message(client_id, {
                    'type': 'game_end',
                    'game_id': self.id,
                    'winner': winner,
                    'duration': self.end_time - self.start_time,
                    'players': list(self.players.values())
                })

        if self.debug:
            print(f"Session {self.id}: Game ended, winner: {winner}")

    def update(self, frame_number, frame_inputs):
        """
        更新游戏状态

        Args:
            frame_number: 帧号
            frame_inputs: 帧输入数据
        """
        if self.status != "running":
            return

        # 游戏逻辑更新将在这里实现
        # 这里只是一个简单的示例，实际游戏逻辑会更复杂

        # 更新时间戳
        self.game_state["timestamp"] = time.time()

        # 更新帧号
        self.game_state["frame"] = frame_number

    def get_state(self):
        """
        获取当前游戏状态

        Returns:
            游戏状态字典
        """
        return self.game_state

    def calculate_checksum(self):
        """
        计算游戏状态的校验和

        Returns:
            校验和字符串
        """
        # 创建状态副本并移除不稳定元素
        state_copy = dict(self.game_state)
        state_copy.pop("timestamp", None)

        # 序列化状态并计算哈希
        state_str = json.dumps(state_copy, sort_keys=True)
        checksum = hashlib.md5(state_str.encode()).hexdigest()

        return checksum

    def reset(self):
        """重置会话状态"""
        self.status = "waiting"
        self.start_time = 0
        self.end_time = 0
        self.game_state = {
            "tanks": [],
            "bullets": [],
            "game_over": False,
            "winner": None,
            "timestamp": time.time()
        }

        # 重置玩家状态
        for player_id in self.players:
            self.players[player_id]["ready"] = False
            self.players[player_id]["score"] = 0
            self.players[player_id]["kills"] = 0
            self.players[player_id]["deaths"] = 0

        if self.debug:
            print(f"Session {self.id}: Reset to waiting state")

    def set_player_ready(self, client_id, ready=True):
        """
        设置玩家准备状态

        Args:
            client_id: 客户端ID
            ready: 准备状态
        """
        if client_id not in self.players:
            return

        self.players[client_id]["ready"] = ready

        if self.debug:
            print(f"Session {self.id}: Player {client_id} ready: {ready}")

        # 检查是否所有玩家都准备好了
        all_ready = all(player["ready"] for player in self.players.values())

        if all_ready and self.status == "waiting" and self.room:
            # 自动开始游戏
            self.room.start_game()

    def get_player_data(self, client_id):
        """
        获取玩家数据

        Args:
            client_id: 客户端ID

        Returns:
            玩家数据字典
        """
        return self.players.get(client_id)

    def get_all_players(self):
        """
        获取所有玩家数据

        Returns:
            玩家数据字典列表
        """
        return list(self.players.values())

    def serialize(self):
        """
        序列化会话信息

        Returns:
            会话信息字典
        """
        return {
            "id": self.id,
            "status": self.status,
            "player_count": len(self.players),
            "start_time": self.start_time,
            "end_time": self.end_time,
            "duration": self.end_time - self.start_time if self.end_time else 0,
            "game_over": self.game_state.get("game_over", False),
            "winner": self.game_state.get("winner")
        }

文件名: test/test_connection.py
文件内容
======================================================================
import asyncio
import websockets
import json
import sys

# 定义一个统一的端口
PORT = 8766


async def test_server():
    print("Testing WebSocket server...")
    try:
        uri = f"ws://localhost:{PORT}"
        print(f"Connecting to {uri}...")
        async with websockets.connect(uri) as websocket:
            print("Connected to server!")

            # 等待服务器的welcome消息
            response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
            data = json.loads(response)
            print(f"Received from server: {data}")

            # 发送一个测试消息
            test_msg = {"type": "test", "message": "Hello Server!"}
            await websocket.send(json.dumps(test_msg))
            print(f"Sent test message: {test_msg}")

            # 等待1秒后退出
            await asyncio.sleep(1)
            print("Test completed successfully!")
            return True
    except Exception as e:
        print(f"Test failed: {e}")
        return False


async def test_client():
    print("Testing as WebSocket server...")
    try:
        # 创建一个简单的echo服务器
        async def echo(websocket, path):
            print("Client connected!")
            await websocket.send(json.dumps({"type": "welcome", "message": "Hello Client!"}))
            async for message in websocket:
                print(f"Received: {message}")
                await websocket.send(message)

        # 启动服务器
        server = await websockets.serve(echo, "localhost", PORT)
        print(f"Echo server running on port {PORT}")

        # 等待10秒后退出
        await asyncio.sleep(10)
        server.close()
        await server.wait_closed()
        print("Echo server stopped")
        return True
    except Exception as e:
        print(f"Test failed: {e}")
        return False


async def main():
    if len(sys.argv) > 1 and sys.argv[1] == "server":
        await test_client()
    else:
        await test_server()


if __name__ == "__main__":
    asyncio.run(main())

文件名: test/test_tank_movement.py
文件内容
======================================================================
# client/tests/test_tank_movement.py
"""
测试坦克移动和旋转是否正常工作
"""

import pygame
import sys
import os


from common.constants import *
from client.game_engine.tank import Tank
from client.game_engine.map import Map
from client.game_engine.obstacle import WallObstacle


def main():
    """测试坦克移动和旋转"""
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Tank Movement Test")
    clock = pygame.time.Clock()

    # 创建地图
    game_map = Map()
    game_map.generate_random_map(seed=42)

    # 创建坦克在地图中央
    tank = Tank(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, 'blue', is_player=True)

    # 显示当前方向和位置的函数
    font = pygame.font.SysFont(None, 24)

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    running = False

        # 处理按键
        keys = pygame.key.get_pressed()

        # 记录移动前的位置
        old_x, old_y = tank.x, tank.y

        # 重置移动标志
        tank.moving = False

        # 处理移动和方向
        if keys[pygame.K_w] or keys[pygame.K_UP]:
            tank.move_in_direction(Tank.UP, game_map.obstacles)
        elif keys[pygame.K_d] or keys[pygame.K_RIGHT]:
            tank.move_in_direction(Tank.RIGHT, game_map.obstacles)
        elif keys[pygame.K_s] or keys[pygame.K_DOWN]:
            tank.move_in_direction(Tank.DOWN, game_map.obstacles)
        elif keys[pygame.K_a] or keys[pygame.K_LEFT]:
            tank.move_in_direction(Tank.LEFT, game_map.obstacles)

        # 清屏
        screen.fill(COLOR_BLACK)

        # 绘制地图
        game_map.draw(screen)

        # 绘制坦克
        tank.draw(screen)

        # 显示信息
        direction_text = font.render(f"Direction: {tank.direction}°", True, COLOR_WHITE)
        screen.blit(direction_text, (10, 10))

        position_text = font.render(f"Position: ({tank.x:.1f}, {tank.y:.1f})", True, COLOR_WHITE)
        screen.blit(position_text, (10, 30))

        moved_text = font.render(
            f"Moved: {tank.x - old_x:.1f}, {tank.y - old_y:.1f}",
            True, COLOR_WHITE
        )
        screen.blit(moved_text, (10, 50))

        # 添加控制提示
        controls_text = font.render("WASD: Move | ESC: Quit", True, COLOR_WHITE)
        screen.blit(controls_text, (10, SCREEN_HEIGHT - 30))

        pygame.display.flip()
        clock.tick(FPS)

    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()

文件名: test/test_websocket.py
文件内容
======================================================================
# test_both.py
import asyncio
import websockets
import json


async def server_handler(websocket, path):
    print("[Test] Client connected!")
    await websocket.send(json.dumps({"type": "welcome", "message": "Hello!"}))
    async for message in websocket:
        print(f"[Test] Server received: {message}")
        await websocket.send(json.dumps({"type": "echo", "content": json.loads(message)}))


async def client():
    await asyncio.sleep(0.5)  # 确保服务器有时间启动
    try:
        uri = "ws://localhost:8765"
        print(f"[Test] Client connecting to {uri}...")
        async with websockets.connect(uri) as websocket:
            print("[Test] Client connected!")

            # 接收welcome消息
            response = await websocket.recv()
            print(f"[Test] Client received: {response}")

            # 发送测试消息
            test_msg = json.dumps({"type": "test", "message": "Hello Server!"})
            await websocket.send(test_msg)
            print(f"[Test] Client sent: {test_msg}")

            # 接收回应
            response = await websocket.recv()
            print(f"[Test] Client received response: {response}")

            await asyncio.sleep(1)
            print("[Test] Client done")
    except Exception as e:
        print(f"[Test] Client error: {e}")


async def main():
    # 启动服务器
    server = await websockets.serve(server_handler, "localhost", 8765)
    print("[Test] Server started on localhost:8765")

    # 启动客户端
    client_task = asyncio.create_task(client())

    # 等待客户端完成
    await client_task

    # 关闭服务器
    server.close()
    await server.wait_closed()
    print("[Test] Test completed")


if __name__ == "__main__":
    asyncio.run(main())

